---
title: 
aliases: 
tags: 
description:
---

# 备注(声明)：




# 一、初入数据结构

## 资料汇总
### 1 、学习资料库
E:\obsidian\local_date\ming\RK3568（linux学习）\linux开发资料库\课件_LV 03_数据结构【认准一手V：it1646,其他均为转卖盗版】

### 2 、视频链接
[初识数据结构，十天搞定嵌入式数据结构_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ee4y1q77b?spm_id_from=333.788.recommend_more_video.1&vd_source=83485b71343f442522d28357f4bb93eb)

[十天搞定嵌入式数据结构和算法基础_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV18C411h7RV?spm_id_from=333.788.recommend_more_video.1&vd_source=83485b71343f442522d28357f4bb93eb)

[数据结构-什么是数据结构](file:///D:/桌面/学习资料/华清嵌入式/03%20华清嵌入式/嵌入式%20-%20课件资源/课件_LV%2003_数据结构【认准一手V：it1646,其他均为转卖盗版】/Day1【认准一手V：it1646,其他均为转卖盗版】/Day1/数据结构-什么是数据结构.pptx)

### 3 、




## 初识数据结构
### 1 、学习数据结构要做到
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648089.png|Open: Pasted image 20250708212431.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648089.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648089.png)

- 1 多模仿模仿多敲一敲，当然如果你那个自己的思路没有一步到位，这个没关系啊，写多了练多了，哪怕照着写，写多了，那你的思维也会得到强化，也会越写越好的。

### 2 、数据结构的本质
- 1 数据结构就是一种思维方式
- 1 面向对象思想              增删改查

- 1 当中有n个数据元素，任何一种数据结构都可以抽象成
- 2 两个元素之间到底是什么关系，直接前去还是直接后继啊
- 2 到底有多少个是一对一还是一对n还是n对n

### 3 、数据结构举例
[“01初识数据结构”页上的图片](onenote:#01初识数据结构&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={F85B119D-6A41-4C1B-8A85-969FB086D134}&object-id={3010B487-A8D4-0CBB-2E0F-8DFF320A8D84}&3D&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 4 、学习数据结构的意义
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648240.png|Open: Pasted image 20250708212656.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648240.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648240.png)



### 5、


## 数据结构-三要素（计算机数据间关系）
### 1 、三要素：逻辑结构、存储结构、操作
- 1 哪些操作
- 2 增长改查呀      排序

- 1 用数据结构
- 2 使我的代码可读性更好，复用性更好，效率更高更好维护


### 2 、基本概念（数据、数据元素）
- 1 数据元素得有实际的现实意义，得符合你的场景才可以
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648812.png|Open: Pasted image 20250708213247.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648812.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648812.png)
### 3 、数据的逻辑结构（线形结构、树、图）
[“数据结构-三要素”页上的图片](onenote:#数据结构-三要素&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={1A3EED13-A9EB-4618-AB91-EE529B96EEFE}&object-id={D5C7D6BB-D055-4992-A659-45A2309CC903}&20&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 4 、数据的存储结构
#### 顺序存储
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648858.png|Open: Pasted image 20250708213605.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648858.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648858.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171649247.png|Open: Pasted image 20250708213614.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171649247.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171649247.png)
#### 链式存储(重点)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171650219.png|Open: Pasted image 20250708213733.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171650219.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171650219.png)

#### 索引存储
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171650290.png|Open: Pasted image 20250708213758.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171650290.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171650290.png)


#### 散列存储
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171651144.png|Open: Pasted image 20250708213823.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171651144.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171651144.png)

### 5、数据结构的三个方面总结
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171651767.png|Open: Pasted image 20250708213935.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171651767.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171651767.png)

### 6、




# 二、线性表（顺序存储结构）

## 线性表之顺序表-介绍
### 1 、线性表定义（L=(a1,a2, ......an-1)）（先后次序关系）
[“线性表之顺序表-介绍”页上的图片](onenote:#线性表之顺序表-介绍&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={455A3D15-DF42-4AD2-8A1F-256F2B9C08E4}&object-id={B4A459B4-2212-006D-15A9-E346DC22241E}&29&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 2 、线性表的特征
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171652244.png|Open: Pasted image 20250708215526.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171652244.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171652244.png)

### 3 、顺序存储结构的表示（一片连续的存储空间）
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171652668.png|Open: Pasted image 20250708215657.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171652668.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171652668.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653200.png|Open: Pasted image 20250708215813.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653200.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653200.png)

### 4 、顺序存储结构的特点
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653388.png|Open: Pasted image 20250708215741.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653388.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653388.png)

### 5、线性表的顺序存储缺点
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653547.png|Open: Pasted image 20250708231133.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653547.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653547.png)

### 6、



## 顺序表-相关算法介绍
### 1 、线性表的基本运算
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653712.png|Open: Pasted image 20250708220127.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653712.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653712.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653904.png|Open: Pasted image 20250708220134.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653904.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171653904.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654069.png|Open: Pasted image 20250708220216.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654069.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654069.png)



### 2 、基本运算的相关算法
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654221.png|Open: Pasted image 20250708220201.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654221.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654221.png)

### 3 、代码编写格式（方便复用）
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654393.png|Open: Pasted image 20250708220256.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654393.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654393.png)
- 1 .h文件     每一个函数它清晰
- 2 对外的接口什么名称、什么参数 、什么返回值、相当于是一个功能的使用手册


### 4 、




## 创建线性表 - sqlink list_create() 
### 1 、思路解析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654559.png|Open: Pasted image 20250708220912.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654559.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654559.png)

### 2 、代码编写 - 创建一个新的空线性表，并返回指向该线性表的指针。
> sqlink list_create() {
	    sqlink L; // 定义一个指向线性表的指针
	    // 使用 malloc 分配内存
	    `L = (sqlink)malloc(sizeof(sqlist));`
	    if (L == NULL) { // 检查内存分配是否成功
	        printf("list malloc failed\n");
	        return L;
	    }
	    // 初始化线性表的数据区以及 last 指针
	    `memset(L, 0, sizeof(sqlist)); // 清空结构体内容
	    `L->last = -1; // 表示线性表为空
	    return L; // 返回新创建的线性表指针
	}

### 3 、线性表数据结构体-定义
> typedef struct {
>     data_t data[N]; // 存储元素的数组
>     int last;       // 最后一个有效元素的位置索引
> }`sqlist, *sqlink`; // sqlink 是指向 sqlist 类型的指针别名
> 

### 4 、


## 插入新的元素 - list_insert(sqlink L, data_t value, int pos)
### 1 、思路解析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654721.png|Open: Pasted image 20250708221147.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654721.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654721.png)

### 2 、代码编写 - 在线性表 L 的 pos 位置插入新的元素 value。
> int list_insert(sqlink L, data_t value, int pos) {
>     if (`L->last == N-1`) { // 判断是否已满
>         printf("list is full\n");
>         return -1;
>     }
>     
>     if (`pos < 0 || pos > L->last+1`) { // 参数验证
> 
>         printf("Pos is invalid\n");
> 
>         return -1;
> 
>     }
> 
>     for (`int i = L->last; i >= pos; i--`) { // <span style="background:#d3f8b6">向后移动数据腾出空间</span>
> 
>         `L->data[i+1] = L->data[i];
> 
>     }
> 
>     `L->data[pos] = value; // 插入新值
> 
>     L->last++; // 更新最后一个有效元素的位置
> 
>     return 0; // 成功返回0
> 
> }

### 3 、

## 删除指定位置的元素 - list_delete(sqlink L, int pos) 
### 1、思路解析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654881.png|Open: Pasted image 20250708225638.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654881.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171654881.png)


### 2、代码编写 - 从线性表 L 中删除位于 pos 位置的元素。
>  * 功能：从线性表 L 中删除位于 pos 位置的元素。
> 
>  * /
> 
> int list_delete(sqlink L, int pos) {
> 
>     if (L->last == -1) {
> 
>         printf("list is empty\n"); // 如果列表为空则提示
> 
>         return -1;
> 
>     }
> 
>     if (pos < 0 || pos > L->last) { // 参数验证
> 
>         printf("delete pos is invalid\n");
> 
>         return -1;
> 
>     }
> 
>     for (`int i = pos+1; i <= L->last; i++`) { // <span style="background:#d3f8b6">数据向前移动</span>
> 
>         `L->data[i-1] = L->data[i];
> 
>     }
> 
>     `L->last--; // 更新最后一个有效元素的位置
> 
>     return 0; // 成功返回0
> 
> }

### 3、




## 在 L 中查找等于 value 的元素，并返回其位置索引
### 1、代码编写
>  * 功能：在 L 中查找等于 value 的元素，并返回其位置索引。
> 
>  * /
> 
> int list_locate(sqlink L, data_t value) {
> 
>     `for (int i = 0; i <= L->last; i++) { // 遍历线性表
> 
>         if (L->data[i] == value)
> 
>             `return i; // 找到匹配值则返回索引
> 
>     }
> 
>     return -1; // 未找到时返回-1
> 
> }

### 2、






## 合并两个有序线性表
### 1、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655054.png|Open: Pasted image 20250708225712.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655054.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655054.png)

### 2、代码编写 - 合并两个有序线性表 L1 和 L2。
>  * 功能：合并两个有序线性表 L1 和 L2。
> 
>  * /
> 
> int list_merge(sqlink L1, sqlink L2) {
> 
>     for (int i = 0; i <= L2->last; i++){
> 
>         `int ret = list_locate(L1, L2->data[i]); // 查找元素是否已存在
> 
>         if (ret == -1) { // 如果不存在，则插入
> 
>             if (`list_insert(L1, L2->data[i], L1->last+1)` == -1)
> 
>                 return -1; // 插入失败则返回失败
> 
>         }
> 
>     }
> 
>     return 0; // 成功返回0
> 
> }



## 去除线性表 L 中重复的元素
### 1、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655238.png|Open: Pasted image 20250708230631.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655238.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655238.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655505.png|Open: Pasted image 20250708230649.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655505.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655505.png)
### 2、代码编写 - 与前面的比较
>  * 函数：list_purge
> 
>  * 功能：去除线性表 L 中重复的元素。
> 
>  * /
> 
> int list_purge(sqlink L) {
> 
>     if (L->last == 0) return 0; // 如果只有一个元素，则无需去重
> 
>     for (`int i = 1; i <= L->last; i++`) {
> 
>         for (`int j = i-1; j >= 0; j--`) {
> 
>             if (`L->data[i] == L->data[j]`) {
> 
>                 list_delete(L, i); // <span style="background:#d3f8b6">删除重复元素</span>
> 
>                 break;
> 
>             } else { j--;}
> 
>         }
> 
>         if (j < 0) {
> 
>             i++;
> 
>         }
> 
>     }
> 
>     return 0; // 成功返回0
> 
> }







## 全部代码分析
[Sqlist.c](onenote:#Sqlist.c&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={7EBA2138-3014-4C27-887B-EF80DBCBE3CE}&end&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

# 三、单链表

## 建立单链表
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655573.png|Open: Pasted image 20250708231431.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655573.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655573.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655829.png|Open: Pasted image 20250708231441.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655829.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655829.png)
### 2 、代码编写 - 创建一个新的空链表
>  * @brief 创建一个新的空链表。
> 
>  *
> 
>  * @return <span style="background:#affad1">返回一个指向新创建链表头节点的指针</span>；如果内存分配失败，则返回NULL。
> 
>  * /
> 
> linklist list_create() {
> 
>     linklist H;
> 
>     // 分配内存以创建链表的头节点
> 
>     `H = (linklist)malloc(sizeof(listnode));
> 
>     if (H == NULL) { // 如果内存分配失败
> 
>         printf("malloc failed\n");
> 
>         return H;
> 
>     }
> 
>     `H->data = 0; // 初始化数据为0
> 
>     `H->next = NULL; // 初始状态下，下一个节点为空
> 
>     return H; // 返回新创建的链表头节点
> 
> }

### 3 、链表结构体
>  * 定义一个名为node的结构体，该结构体表示链表中的节点。
> 
>  * 每个节点包含两个部分：
> 
>  * - data: 存储的数据，类型是之前定义的data_t（在这里实际上是int）。
> 
>  * - next: 指向下一个节点的指针，类型是指向struct node的指针。
> 
>  * /
> 
> typedef struct node {
> 
>     `data_t data; // 节点存储的数据
> 
>     `struct node * next; // 指向下一个节点的指针
> 
> } listnode, * linklist; // listnode是结构体别名，linklist是指向该结构体的指针的别名


### 4 、


## 尾部插入
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655992.png|Open: Pasted image 20250708231726.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655992.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171655992.png)

### 2 、代码编写 - 在链表尾部插入一个新元素。
>  * @brief 在链表尾部插入一个新元素。
> 
>  *
> 
>  * @param H 链表的头指针。
> 
>  * @param value 将要插入的新元素值。
> 
>  * @return 成功时返回0，失败时返回-1。
> 
>  * /
> 
> int list_tail_insert(linklist H, data_t value) {
> 
>     linklist p;
> 
>     linklist q;
> 
>     if (H == NULL) { // 检查链表头是否有效
> 
>         printf("H is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     // <span style="background:#b1ffff">为新节点p分配内存</span>
> 
>     if ((p = (linklist)malloc(sizeof(listnode))) == NULL) {
> 
>         printf("malloc failed\n");
> 
>         return -1;
> 
>     }
> 
>     `p->data = value; // 设置新节点的数据值
> 
>     `p->next = NULL; // 新节点是最后一个节点，因此它的next指针应设置为NULL
> 
>     // <span style="background:#b1ffff">查找链表的尾节点</span>
> 
>     q = H;
> 
>     while (q->next != NULL) {
> 
>         q = q->next;
> 
>     }
> 
>     // <span style="background:#b1ffff">在尾部插入新节点</span>
> 
>     `q->next = p;
> 
>     return 0;
> 
> }

### 3 、



## 遍历
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656144.png|Open: Pasted image 20250708231745.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656144.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656144.png)

### 2 、代码编写 - 显示链表中的所有元素。
>  * @brief 显示链表中的所有元素。
> 
>  *
> 
>  * @param H 链表的头指针。
> 
>  * @return 成功时返回0，失败时返回-1。
> 
>  * /
> 
> int list_show(linklist H) {
> 
>     linklist p;
> 
>     if (H == NULL) { // 检查链表头是否有效
> 
>         printf("H is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     p = H;
> 
>     // 遍历链表并打印每个节点的数据值
> 
>     while (`p->next != NULL`) {
> 
>         printf("%d ", p->next->data);
> 
>         `p = p->next;`
> 
>     }
> 
>     `puts(""); // 打印完成后换行
> 
>     return 0;
> 
> }

### 3 、



## 链表查找
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656180.png|Open: Pasted image 20250708232511.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656180.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656180.png)

### 2 、代码编写 - 获取链表中指定位置的节点。
> linklist list_get(linklist H, int pos) {
> 
>     linklist p;
> 
>     int i;
> 
>     if (H == NULL) { // <span style="background:#b1ffff">检查链表头是否有效</span>
> 
>         printf("H is NULL\n");
> 
>         return NULL;
> 
>     }
> 
>     if (pos == -1) { //<span style="background:#b1ffff"> 特殊情况：请求头节点</span>
> 
>         return H;
> 
>     }
> 
>     if (pos < -1) { <span style="background:#b1ffff"> // 检查位置是否有效</span>
> 
>         printf("pos is invalid\n");
> 
>         return NULL;
> 
>     }
> 
>     p = H;
> 
>     i = -1;
> 
>     `while (i < pos) {
> 
>         `p = p->next;
> 
>         if (p == NULL) { // <span style="background:#d3f8b6">如果在到达目标位置之前到达链表末尾，则位置无效</span>
> 
>             printf("pos is invalid\n");
> 
>             return NULL;
> 
>         }
> 
>         `i++;
> 
>     }
> 
>     return p;
> 
> }

### 3 、



## 按位置插入
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656358.png|Open: Pasted image 20250708232830.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656358.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656358.png)

### 2 、代码编写 - 在链表的指定位置插入一个新元素。
> int list_insert(linklist H, data_t value, int pos) {
> 
>     linklist p;
> 
>     linklist q;
> 
>     if (H == NULL) { // 检查链表头是否有效
> 
>         printf("H is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     // <span style="background:#b1ffff">定位到需要插入位置的前一个节点</span>
> 
>     `p = list_get(H, pos-1);
> 
>     if (p == NULL) {
> 
>         return -1;
> 
>     }
> 
>     // 为新节点q分配内存
> 
>     if ((q = (linklist)malloc(sizeof(listnode))) == NULL) {
> 
>         printf("malloc failed\n");
> 
>         return -1;
> 
>     }
> 
>     q->data = value; // 设置新节点的数据值
> 
>     q->next = NULL; //
> 
>     // <span style="background:#b1ffff">插入新节点</span>
> 
>     `q->next = p->next;
> 
>     `p->next = q;
> 
>     return 0;
> 
> }
> 
### 3 、



## 链表删除
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656527.png|Open: Pasted image 20250708233026.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656527.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656527.png)

### 2 、代码编写 - 删除链表中指定位置的节点
> int list_delete(linklist H, int pos) {
> 
>     linklist p, q;
> 
>     if (H == NULL) {  // 检查链表是否为空
> 
>         printf("H is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     <span style="background:#b1ffff">// 定位到要删除节点的前一个节点</span>
> 
>     p = list_get(H, pos-1);
> 
>     if (p == NULL)
> 
>         return -1;
> 
>     if (p->next == NULL) {  // 如果下一个节点不存在
> 
>         printf("delete pos is invalid\n");
> 
>         return -1;
> 
>     }
> 
>     // <span style="background:#b1ffff">更新链表连接关系</span>
> 
>     `q = p->next;`    <span style="background:#d3f8b6">先保存要删除的节点</span>
> 
>     `p->next = q->next;
> 
>     // <span style="background:#b1ffff">释放被删除节点的内存</span>
> 
>     printf("free:%d\n", q->data);
> 
>     free(q);
> 
>     q = NULL;
> 
>     return 0;  // 成功返回0
> 
> }

### 3 、



## 链表释放
### 1 、思路分析


### 2 、代码编写
> // 释放整个链表占用的内存
> 
> linklist list_free(linklist H) {
> 
>     linklist p;
> 
>     if (H == NULL)
> 
>         return NULL;
> 
>     p = H;
> 
>     // <span style="background:#b1ffff">逐个节点释放内存</span>
> 
>     printf("free:");
> 
>     while (H != NULL) {
> 
>         `p = H;
> 
>         printf("%d ", p->data);  // 打印将要释放的节点数据
> 
>         `free(p);  // 释放当前节点
> 
>                   //这段代码存在未定义行为，其核心问题在于释放节点后仍然尝试访问已释放内存中的指针域。应该先H=H->next,再free(p)
> 
>         `H = H->next;  // 移动到下一个节点
> 
>     }
> 
>     puts("");  // 打印完所有数据后换行
> 
>     return NULL;  // 返回NULL表示链表已被完全释放
> 
> }
> 
### 3 、

## 链表的反转
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656698.png|Open: Pasted image 20250709142750.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656698.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656698.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656863.png|Open: Pasted image 20250709142803.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656863.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171656863.png)



### 2 、代码编写 - 反转链表中节点的顺序。
> int list_reverse(linklist H) {
> 
>     linklist p;
> 
>     linklist q;
> 
>     if (H == NULL) { // 检查链表头指针是否为空
> 
>         printf("H is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     if (H->next == NULL || H->next->next == NULL) { // <span style="background:#b1ffff">若链表为空或只有一个节点则无需反转</span>
> 
>         return 0;
> 
>     }
> 
>     `p = H->next->next;` // <span style="background:#affad1">p 指向第二个节点之后的第一个节点,保存节点</span>
> 
>     `H->next->next = NULL;` // <span style="background:#affad1">第一个节点变为尾节点，其 next 指针设为 NULL</span>
> 
>     // <span style="background:#b1ffff">反转链表</span>
> 
>     while (p != NULL) {
> 
>         `q = p;
> 
>         `p = p->next; // p 向前移动
> 	// <span style="background:#affad1">将 q 节点插入到链表头部</span>
>         `q->next = H->next; 
> 
>         `H->next = q;
> 
>     }
> 
>     return 0;
> 
> }

### 3 、


## 链表求相邻两个结点最大值
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657021.png|Open: Pasted image 20250709144819.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657021.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657021.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657341.png|Open: Pasted image 20250709144853.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657341.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657341.png)


- 1 用p和q遍历所有相邻节点，判断是否为最大值，是的话将第一个节点指针存储，最后返回

### 2 、代码编写 - 查找链表中与指定值相邻的最大值节点。
> linklist list_adjmax(linklist H, data_t * value) {
> 
>     linklist p, q, r;
> 
>     data_t sum;
> 
>     if (H == NULL){
> 
>         printf("H is NULL\n");
> 
>         return NULL;
> 
>     }
> 
>     if (H->next == NULL || H->next->next == NULL || H->next->next->next == NULL) {
> 
>         return H;
> 
>     }
> 
>     `q = H->next;
> 
>     `p = H->next->next;     //p = q->next;
> 
>     `r = q;   保存
> 
>     sum = q->data + p->data;
> 
>     while (p->next != NULL) {
> 
>         `p = p->next;
> 
>         `q = q->next;
> 
>         if (`sum < q->data + p->data`) {
> 
>             `sum = q->data + p->data;
> 
>             r = q;
> 
>         }
> 
>     }
> 
>     * value = sum;
> 
>     return r;
> 
> }

### 3 、


## 有序链表合并
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657528.png|Open: Pasted image 20250709145134.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657528.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657528.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657694.png|Open: Pasted image 20250709145240.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657694.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657694.png)


### 2 、代码编写 - 合并两个已排序的链表为一个新的已排序链表。
> int list_merge(linklist H1, linklist H2) {
> 
>     linklist p, q, r;
> 
>     if (H1 == NULL || H2 == NULL) {
> 
>         printf("H1 || H2 is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     `p = H1->next;
> 
>     `q = H2->next;
> 
>     `r = H1;
> 
>     H1->next = NULL;
> 
>     H2->next = NULL;
> 
>     // <span style="background:#b1ffff">合并两个链表</span>
> 
>     while (p && q) {
> 
>         if (`p->data <= q->data`) {
> 
>             `r->next = p;
> 
>             `p = p->next;
> 
>             `r = r->next;
> 
>             r->next = NULL;
> 
>         } `else` {
> 
>             `r ->next = q;
> 
>             `q = q->next;
> 
>             `r = r->next;
> 
>             r->next = NULL;
> 
>         }
> 
>     }
> 
>     // <span style="background:#b1ffff">连接剩余节点</span>
> 
>     if (`p == NULL`) {
> 
>         `r->next = q;
> 
>     }else {
> 
>         r->next = p;
> 
>     }
> 
>     return 0;
> 
> }

### 3 、


## 全部代码分析
[Linklist.c](onenote:#Linklist.c&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={2561F54D-4BC2-4643-BE36-6BA8B76CC5CB}&end&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)


# 四、顺序栈

## 顺序栈的原理-线性化
### 1 、栈的定义 - 先进后出
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657854.png|Open: Pasted image 20250709155851.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657854.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171657854.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171658048.png|Open: Pasted image 20250709155859.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171658048.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171658048.png)
### 2 、栈的应用

[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171658674.png|Open: Pasted image 20250709155916.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171658674.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171658674.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659041.png|Open: Pasted image 20250709155942.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659041.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659041.png)


### 3 、顺序栈的数据结构体讲解
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659350.png|Open: Pasted image 20250709160146.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659350.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659350.png)

>  * 栈结构体定义。
>  * - data: 指向一个动态分配的数据区，用于存储栈中的元素；
>  * - maxlen: 栈的最大容量；
>  * - top: 栈顶指针，指向当前栈顶元素的位置。初始化时为-1，表示栈为空。
>  * 
> typedef struct {
> 
>     `data_t * data; // 动态数组，存放栈内元素
> 
>     `int maxlen;   // 栈的最大长度
> 
>     `int top;      // 栈顶索引，初始值为-1，意味着栈为空
> 
> } sqstack;
> 
> // 定义数据类型 data_t 为 int 类型，用于存储在栈中的元素
>
`typedef int data_t;
> 


## 创建栈
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659601.png|Open: Pasted image 20250709160313.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659601.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659601.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659909.png|Open: Pasted image 20250709160334.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659909.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171659909.png)
### 2 、代码编写
> sqstack* stack_create(int len) {
> 
>     sqstack * s;
> 
>     // <span style="background:#b1ffff">分配栈结构体所需的内存</span>
> 
>     if (`(s =(sqstack * )malloc(sizeof(sqstack)))` == NULL) {
> 
>         printf("malloc sqstack failed\n");
> 
>         return NULL;
> 
>     }
> 
>     // 分配用于存储栈数据的内存
> 
>     if ((s->data = (data_t * )malloc(len *  sizeof(data_t))) == NULL) {
> 
>         printf("malloc data failed\n");
> 
>         free(s);
> 
>         return NULL;
> 
>     }
> 
>     // 初始化栈中的数据区为0
> 
>     memset(s->data, 0, len* sizeof(data_t));
> 
>     s->maxlen = len; // 设置栈的最大长度
> 
>     `s->top = -1;     // 初始化栈顶索引为-1，表示栈为空
> 
>     return s;
> 
> }

### 3 、


## 出栈
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700055.png|Open: Pasted image 20250709160443.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700055.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700055.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700247.png|Open: Pasted image 20250709160518.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700247.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700247.png)
### 2 、代码编写 - 从栈中弹出一个元素。
> data_t stack_pop(sqstack * s) {
> 
>     if (s == NULL || s->top == -1) { // 检查栈指针及栈空情况
> 
>         printf("stack is empty\n");
> 
>         return 0; // 或者可以根据需要调整返回值
> 
>     }
> 
>     `data_t value = s->data[s->top]; // 获取栈顶元素
> 
>     `s->top--; // 更新栈顶位置
> 
>     return value;
> 
> }

### 3 、


## 入栈
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700695.png|Open: Pasted image 20250709160536.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700695.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700695.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700809.png|Open: Pasted image 20250709160547.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700809.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171700809.png)
### 2 、代码编写 - 向栈中压入一个元素。
> int stack_push(sqstack * s, data_t value) {
> 
>     if (s == NULL) { // 检查栈是否为空
> 
>         printf("s is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     if (s->top == s->maxlen-1) { // 检查栈是否已满
> 
>         printf("stack is full\n");
> 
>         return -1;
> 
>     }
> 
>     `s->top++; // 更新栈顶位置
> 
>     `s->data[s->top] = value; // 将新值插入到栈顶
> 
>     return 0;
> 
> }

### 3 、


# 五、链式栈

## 链式栈原理（出栈、入栈、释放内存）
### 1 、链式栈特点
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171701247.png|Open: Pasted image 20250709161620.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171701247.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171701247.png)

### 2 、链式栈数据结构体
>  * 定义链表节点结构体，用于构建链栈
> 
>  * data：存储的数据，类型为data_t（即int）
> 
>  * next：指向下一个节点的指针
>  * 
> typedef struct node {
> 
>     `data_t data; // 数据域，存储实际数据
> 
>     `struct node * next; // 指针域，指向下一个节点
> 
> } listnode, * linkstack; // listnode是普通结构体名，linkstack是指向该结构体的指针类型
> 
### 3 、



## 入栈
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171701429.png|Open: Pasted image 20250709161803.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171701429.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171701429.png)

### 2 、代码编写 - 向栈中压入一个元素
> // 向栈中压入一个元素
> 
> int stack_push(linkstack s, data_t value) {
> 
>     linkstack p;
> 
>     if (s == NULL) { // 检查栈是否有效
> 
>         printf("s is NULL\n");
> 
>         return -1; // 栈无效则返回错误代码
> 
>     }
> 
>     // <span style="background:#b1ffff">分配内存给新的栈节点</span>
> 
>     p = (linkstack)malloc(sizeof(listnode));
> 
>     if (p == NULL) { // 如果内存分配失败
> 
>         printf("malloc failed\n");
> 
>         return -1; // 返回错误代码
> 
>     }
> 
>     p->data = value; // 设置新节点的数据域
> 
>     `p->next = s->next; // 将新节点的next指向当前栈顶的下一个节点
> 
>     `s->next = p; // 更新栈顶指针，使新节点成为新的栈顶
> 
>     return 0; // 成功返回0
> 
> }

### 3 、

## 出栈
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171701672.png|Open: Pasted image 20250709161819.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171701672.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171701672.png)

### 2 、代码编写 - 从栈中弹出一个元素，并返回该元素的值
> // 从栈中弹出一个元素，并返回该元素的值
> 
> data_t stack_pop(linkstack s) {
> 
>     linkstack p;
> 
>     data_t t;
> 
>     `p = s->next; // 获取栈顶元素
> 
>     `s->next = p->next; // 更新栈顶指针，使其指向下一个元素
> 
>     t = p->data; // 保存要返回的数据
> 
>     free(p); // 释放被弹出节点占用的内存
> 
>     p = NULL; // 防止悬挂指针
> 
>     return t; // 返回被弹出的数据
> 
> }

### 3 、


## 释放内存
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702008.png|Open: Pasted image 20250709161833.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702008.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702008.png)

### 2 、代码编写 - 释放整个栈占用的内存
> // 释放整个栈占用的内存
> 
> linkstack stack_free(linkstack s) {
> 
>     linkstack p;
> 
>     if (s == NULL) { // 如果栈不存在
> 
>         printf("s is NULL\n");
> 
>         return NULL; // 返回NULL表示释放失败
> 
>     }
> 
>     while (s != NULL) { // <span style="background:#b1ffff">循环直到栈为空</span>
> 
>         `p = s; // 记录当前节点
> 
>         `s = s->next; // 移动到下一个节点
> 
>         printf("free:%d\n", p->data); // 打印被释放节点的数据
> 
>         `free(p); // 释放当前节点的内存
> 
>     }
> 
>     return NULL; // 全部节点释放完毕后返回NULL
> 
> }

### 3 、




# 六、顺序队列

## 顺序队列的原理-循环队列
### 1 、 认识队列
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702510.png|Open: Pasted image 20250709162401.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702510.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702510.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702586.png|Open: Pasted image 20250709162411.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702586.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702586.png)
### 2 、队列的应用
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702843.png|Open: Pasted image 20250709162449.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702843.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171702843.png)

### 3 、顺序队列数据结构体分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171703012.png|Open: Pasted image 20250709163053.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171703012.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171703012.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171638899.png|Open: Pasted image 20250709163103.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171638899.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171638899.png)

### 4 、顺序存储，循环使用
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639079.png|Open: Pasted image 20250709163136.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639079.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639079.png)

- 1 顺序存储可以循环使用啊，只需要通过取余就可以，循环使用一段空间
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639116.png|Open: Pasted image 20250709163324.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639116.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639116.png)

### 5、

## 创建一个新的循环队列
> sequeue * queue_create() {
> 
>     `sequeue * sq; // 定义一个指向循环队列的指针
> 
>     // 动态分配内存用于存储循环队列结构体，并检查是否成功
> 
>     if ((sq = (sequeue * )malloc(sizeof(sequeue))) == NULL) {
> 
>         printf("malloc failed\n"); // 输出错误信息
> 
>         return NULL;
> 
>     }
> 
>     // 初始化队列数据区为空，设置队首和队尾指针为0
> 
>     memset(sq->data, 0, sizeof(sq->data));
> 
>     `sq->front = sq->rear = 0;
> 
>     return sq; // 返回创建好的队列指针
> 
> }


## 检查循环队列是否为空
> int queue_empty(sequeue * sq) {
> 
>     if (sq == NULL) {
> 
>         printf("sq is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     return (`sq->front == sq->rear ? 1 : 0`); // <span style="background:#affad1">队首与队尾相同表示队列为空</span>
> 
> }




## 向循环队列中添加元素
> int enqueue(sequeue * sq, datatype x) {
> 
>     // 检查传入的队列指针是否为空
> 
>     if (sq == NULL) {
> 
>         printf("sq is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     // 检查队列是否已满
> 
>     if ((sq->rear + 1) % N == sq->front) {
> 
>         printf("sequeue is full\n");
> 
>         return -1;
> 
>     }
> 
>     // <span style="background:#b1ffff">将数据项x添加到队列中，并更新队尾指针</span>
> 
>     `sq->data[sq->rear] = x;
> 
>     `sq->rear = (sq->rear + 1) % N;
> 
>     return 0; // 成功
> 
> }



## 从循环队列中移除并返回第一个元素
> datatype dequeue(sequeue * sq) {
> 
>     datatype ret; // 存储要返回的数据项
> 
>     `ret = sq->data[sq->front]; // 获取队首元素
> 
>     `sq->front = (sq->front + 1) % N; // 更新队首指针
> 
>     return ret; // 返回队首元素
> 
> }



# 七、链式队列

## 链式队列的原理
### 1 、链式队列的原理
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639562.png|Open: Pasted image 20250709164406.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639562.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639562.png)

[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639779.png|Open: Pasted image 20250709164227.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639779.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639779.png)
### 2 、队列操作，原理解析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639873.png|Open: Pasted image 20250709164302.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639873.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171639873.png)

### 3 、链式队列结构体解析
> // 定义数据元素类型为int
> 
> `typedef int datatype;
> 
> /**
> 
>  * 定义单个节点的结构体，包含：
> 
>  * - 数据域：存储实际的数据（此处为datatype类型）
> 
>  * - 指针域：指向下一个节点的指针
> 
>  * /
> 
> typedef struct node {
> 
>     `datatype data; // 节点存储的数据
> 
>     `struct node * next; // 指向下一个节点的指针
> 
> } listnode, * linklist; // listnode是结构体别名，linklist是指向该结构体的指针别名
>  * 定义链式队列的结构体，包含：
> 
>  * - front: 指向队列前端的指针
> 
>  * - rear: 指向队列末端的指针
> 
>  * /
> 
> typedef struct {
> 
>     `linklist front; // 队首指针
> 
>     `linklist rear; // 队尾指针
> 
> } linkqueue;

### 4 、




## 创建队列
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640023.png|Open: Pasted image 20250709164528.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640023.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640023.png)

### 2 、代码编写 - 创建一个新的链式队列并返回其指针。
> linkqueue * queue_create() {
> 
>     linkqueue * lq;
> 
>     // 分配链式队列结构体所需的空间
> 
>     if ((lq = (linkqueue * )malloc(sizeof(linkqueue))) == NULL) {
> 
>         printf("malloc linkqueue failed\n");
> 
>         return NULL;
> 
>     }
> 
>    <span style="background:#b1ffff"> // 初始化队首和队尾，指向一个新分配的节点</span>
> 
>     lq->front = lq->rear = (linklist)malloc(sizeof(listnode));
> 
>     if (lq->front == NULL) {
> 
>         printf("malloc node failed\n");
> 
>         return NULL;
> 
>     }
> 
>     // 设置初始节点的数据域为0，并且next指针为空
> 
>     `lq->front->data = 0;
> 
>     `lq->front->next = NULL;
> 
>     return lq;
> 
> }

### 3 、

## 元素x添加到链式队列lq的末尾。
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640506.png|Open: Pasted image 20250709164545.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640506.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640506.png)

### 2 、代码编写 - 将元素x添加到链式队列lq的末尾。
> int enqueue(linkqueue * lq, datatype x) {
> 
>     linklist p;
> 
>     if (lq == NULL) { // 检查队列是否有效
> 
>         printf("lq is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     // 分配新节点
> 
>     if ((p = (linklist)malloc(sizeof(listnode))) == NULL) {
> 
>         printf("malloc node failed\n");
> 
>         return -1;
> 
>     }
> 
>     p->data = x; // 设置新节点的数据
> 
>     p->next = NULL;
> 
>     <span style="background:#b1ffff">// 将新节点连接到队尾，并更新队尾指针</span>
> 
>     `lq->rear->next = p;
> 
>     `lq->rear = p;
> 
>     return 0;
> 
> }

### 3 、

## 前端移除一个元素
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640672.png|Open: Pasted image 20250709164849.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640672.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640672.png)

### 2 、代码编写 - 从链式队列lq的前端移除一个元素，并返回该元素。
> datatype dequeue(linkqueue * lq) {
> 
>     linklist p;
> 
>     if (lq == NULL) { // 检查队列是否有效
> 
>         printf("lq is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     `p = lq->front; // 保存当前队首节点
> 
>     `lq->front = p->next; // 更新队首指针到下一个节点
> 
>     free(p); // 释放原队首节点
> 
>     p = NULL;
> 
>     return (lq->front->data); // 返回新的队首节点的数据
> 
> }
> 

# 八、球鈡问题(链式队列+顺序栈)

## 球鈡问题分析
### 1 、球鈡问题的定义
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640712.png|Open: Pasted image 20250709165018.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640712.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171640712.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641143.png|Open: Pasted image 20250709165051.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641143.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641143.png)
### 2 、球鈡问题分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641384.png|Open: Pasted image 20250709165102.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641384.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641384.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641454.png|Open: Pasted image 20250709165111.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641454.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641454.png)
### 3 、

## 代码分析
[test.c](onenote:#test.c&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={BF274268-468C-41A1-BF0B-82ADE4C001CF}&end&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)


# 九、树

## 树的概念（一对多）
### 1 、树的基本概念
[“七、树的概念”页上的图片](onenote:#七、树的概念&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={59B5DCD4-BEE3-416C-9F2A-2A155646B499}&object-id={0437E33A-0BC2-0034-03FE-74EB1016D17A}&12&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 2 、


## 二叉树的原理

### 1 、二叉树的概念
[“二叉树的原理”页上的图片](onenote:#二叉树的原理&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={0035F71A-452E-4302-B945-816EB06BC6E8}&object-id={421F3406-FCBE-0E7A-3126-21FCE9D4EE5D}&12&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 2 、二叉树性质
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641572.png|Open: Pasted image 20250709194218.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641572.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641572.png)

### 3 、二叉树-顺序存储（浪费空间）
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641650.png|Open: Pasted image 20250709194331.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641650.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171641650.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642029.png|Open: Pasted image 20250709194343.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642029.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642029.png)

### 4 、二叉树-链式存储
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642184.png|Open: Pasted image 20250709194413.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642184.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642184.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642339.png|Open: Pasted image 20250709194429.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642339.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642339.png)

### 5、



## 二叉树的遍历（递归函数）
### 1 、二叉树的三种遍历了解
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642478.png|Open: Pasted image 20250709194624.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642478.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642478.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642552.png|Open: Pasted image 20250709194725.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642552.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642552.png)
### 2 、创建二叉树（递归函数）
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642687.png|Open: Pasted image 20250709195500.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642687.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642687.png)

[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642745.png|Open: Pasted image 20250709195513.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642745.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171642745.png)

- 1 代码分析
>  * 创建二叉树的递归函数。
> 
>  * 通过用户输入构建二叉树，'#' 表示空节点。
> 
>  * /
> 
> bitree * tree_create() {
> 
>     data_t ch; // 定义一个变量来存储读取的数据
> 
>     bitree * r; // 定义一个指向二叉树节点的指针
> 
>     // 从标准输入读取一个字符
> 
>     scanf("%c", &ch);
> 
>     if (`ch == '#'`) //<span style="background:#b1ffff"> 如果读取到 '#'，表示该位置为空节点</span>
> 
>         return NULL; // 返回空指针
> 
>     // 分配内存给新的二叉树节点
> 
>     if ((r = (bitree * )malloc(sizeof(bitree))) == NULL) {
> 
>         printf("malloc failed\n"); // 输出内存分配失败的信息
> 
>         return NULL; // 返回空指针
> 
>     }
> 
>     `r->data = ch; // 将读取的字符赋值给节点数据域
> 
>     // <span style="background:#b1ffff">递归创建左子树和右子树</span>
> 
>     `r->left  = tree_create();
> 
>     `r->right = tree_create();
> 
>     return r; // 返回创建好的二叉树根节点
> 
> }




### 3 、先序遍历算法讲解 - 先序遍历二叉树。
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643143.png|Open: Pasted image 20250709194812.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643143.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643143.png)

> void preorder(bitree * r) {
> 
>     if (r == NULL) { // 如果当前节点为空，则直接返回
> 
>         return;
> 
>     }
> 
>     printf("%c", r->data); // 打印当前节点的数据
> 
>     `preorder(r->left); // 递归遍历左子树
> 
>     `preorder(r->right); // 递归遍历右子树
> 
> }
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643344.png|Open: Pasted image 20250709195355.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643344.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643344.png)


### 4 、了解遍历算法的方法
- 1 比较好的解决方法就是找一棵树，你把你的程序跑一遍，把递归过程全部把它画出来，你画几遍你就会有感觉了。

### 5、




## 递归调用算法讲解
[递归调用](onenote:#递归调用&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={F7C67DE3-01FF-42F2-9766-0F261BED8164}&end&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)
### 1 、


### 2 、


### 3 、

### 4 、


## 二叉树的层次遍历
### 1 、思路分析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643454.png|Open: Pasted image 20250709200101.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643454.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643454.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643576.png|Open: Pasted image 20250709200114.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643576.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643576.png)

### 2 、代码分析（层序遍历二叉树（广度优先搜索））
> void layerorder(bitree * r) {
> 
>     linkqueue * lq; // 定义一个指向队列的指针
> 
>     // 创建一个新的队列，如果失败则直接返回
> 
>     if ((lq = queue_create()) == NULL)
> 
>         return;
> 
>     // 如果根节点为空，则直接返回
> 
>     if (r == NULL)
> 
>         return;
> 
>     printf("%c", r->data); // 打印根节点的数据
> 
>     enqueue(lq, r); // 根节点入队
> 
>     // 当队列不为空时，继续遍历
> 
>     while (!queue_empty(lq)) {
> 
> <span style="background:#b1ffff">不断地向下找，一层一层的加入然后一层一层的去掉 。</span>
> 
>         `r = dequeue(lq); // 出队并获取节点
> 
>         // <span style="background:#affad1">如果左子节点存在，则打印其数据并将其加入队列</span>
> 
>         if (r->left) {
> 
>             printf("%c", r->left->data);
> 
>             enqueue(lq, r->left);
> 
>         }
> 
>         //<span style="background:#affad1"> 如果右子节点存在，则打印其数据并将其加入队列</span>
> 
>         if (r->right) {
> 
>             printf("%c", r->right->data);
> 
>             enqueue(lq, r->right);
> 
>         }
> 
>     }      
> 
>     puts(""); // 输出换行符，以便于格式化输出结果
> 
> }

### 3 、





# 十、查找

## 查找的原理
### 1 、查找概念
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643711.png|Open: Pasted image 20250709200325.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643711.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643711.png)

### 2 、查找方法汇总
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643758.png|Open: Pasted image 20250709200356.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643758.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643758.png)

### 3 、查找-平均查找长度
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643942.png|Open: Pasted image 20250709200555.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643942.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171643942.png)

### 4 、顺序表的查找
[“八、查找的原理”页上的图片](onenote:#八、查找的原理&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={EDCDFCDF-F9CA-49A0-8B0C-31EFF5D9D5D9}&object-id={126554C5-4C9C-010B-2539-52684D16AECF}&11&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 5、顺序查找算法及分析
[“八、查找的原理”页上的图片](onenote:#八、查找的原理&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={EDCDFCDF-F9CA-49A0-8B0C-31EFF5D9D5D9}&object-id={126554C5-4C9C-010B-2539-52684D16AECF}&1D&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 6、折半查找算法及分析
[“八、查找的原理”页上的图片](onenote:#八、查找的原理&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={EDCDFCDF-F9CA-49A0-8B0C-31EFF5D9D5D9}&object-id={126554C5-4C9C-010B-2539-52684D16AECF}&2F&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 7、分块查找算法及分析（索引顺序查找）
[“八、查找的原理”页上的图片](onenote:#八、查找的原理&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={EDCDFCDF-F9CA-49A0-8B0C-31EFF5D9D5D9}&object-id={126554C5-4C9C-010B-2539-52684D16AECF}&57&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 8、总结

[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171644602.png|Open: Pasted image 20250709200645.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171644602.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171644602.png)

## 哈希表的原理
- 1 哈希表是所有的查找算法当中效率最高的
### 1 、Hash表的查找
[“哈希表的原理”页上的图片](onenote:#哈希表的原理&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={47370DBA-E1CE-4679-BA45-E3D3A0402284}&object-id={7F7E9AAD-66A8-4060-B9F5-69168FF9E1DA}&12&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171644690.png|Open: Pasted image 20250709200915.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171644690.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171644690.png)
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171644771.png|Open: Pasted image 20250709200926.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171644771.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171644771.png)


### 2 、“冲突”的了解
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171645422.png|Open: Pasted image 20250709200839.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171645422.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171645422.png)

### 3 、常用的构造方法（减少冲突）
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171645872.png|Open: Pasted image 20250709201110.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171645872.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171645872.png)

### 4 、保留除数法 - 讲解
[“哈希表的原理”页上的图片](onenote:#哈希表的原理&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={47370DBA-E1CE-4679-BA45-E3D3A0402284}&object-id={7F7E9AAD-66A8-4060-B9F5-69168FF9E1DA}&5F&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 5、开放地址法 - 讲解
[“哈希表的原理”页上的图片](onenote:#哈希表的原理&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={47370DBA-E1CE-4679-BA45-E3D3A0402284}&object-id={7F7E9AAD-66A8-4060-B9F5-69168FF9E1DA}&B4&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 6、链地址法 - 讲解
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646037.png|Open: Pasted image 20250709201259.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646037.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646037.png)

- 1 链式哈希用的是比较多
### 7、





## hash表的实现-创建（链地址法）
>  * 创建一个新的哈希表。
> 
>  * 返回值：指向新创建的哈希表的指针；如果分配内存失败，则返回 NULL。
> 
>  * /
> 
> hash * hash_create() {
> 
>     hash * HT; // 定义一个指向哈希表的指针
> 
>     // 分配内存以存储哈希表结构体，并检查是否分配成功
> 
>     if ((`HT = (hash * )malloc(sizeof(hash))`) == NULL) {
> 
>         printf("malloc failed\n"); // 打印错误信息
> 
>         return NULL;
> 
>     }
> 
>     // <span style="background:#affad1">使用 memset 初始化哈希表的所有字节为 0，确保数据干净</span>
> 
>     `memset(HT, 0, sizeof(hash));
> 
>     return HT; // 返回初始化好的哈希表
> 
> }
> 

## 哈希表的实现-向哈希表中插入一个键值对
> int hash_insert(hash * HT, datatype key) {
> 
>     linklist p, q; // 定义两个链表节点指针变量
> 
>     // 检查哈希表是否存在
> 
>     if (HT == NULL) {
> 
>         printf("HT is NULL\n");
> 
>         return -1;
> 
>     }
> 
>     // 为新节点分配内存，并检查是否分配成功
> 
>     if ((p = (linklist)malloc(sizeof(listnode))) == NULL) {
> 
>         printf("malloc failed\n");
> 
>         return -1;
> 
>     }
> 
>     `p->key = key; // 设置新节点的键
> 
>     `p->value = key % N; // 计算哈希值作为值
> 
>     p->next = NULL; // 初始化新节点的 next 指针为空
> 
>     // 获取与哈希值对应的链表头部节点地址
> 
>     `q = &(HT->data[key % N]);
> 
>     // <span style="background:#affad1">遍历链表，找到插入点</span>
> 
>     while (q->next && q->next->key < p->key ) {
> 
>         q = q->next;
> 
>     }
> 
>     // <span style="background:#affad1">插入新节点到链表中适当位置.</span>
> 
>     p->next = q->next;
> 
>     q->next = p;
> 
>     return 0; // 成功返回 0
> 
> }

## 哈希表的实现-在哈希表中查找指定键的元素。
> linklist hash_search(hash * HT, datatype key) {
> 
>     linklist p; // 定义一个链表节点指针变量
> 
>     // 检查哈希表是否存在
> 
>     if (HT == NULL) {
> 
>         printf("HT is NULL\n");
> 
>         return NULL;
> 
>     }
> 
>     // 获取与哈希值对应的链表头部节点地址
> 
>     p = &(HT->data[key % N]);
> 
>     // <span style="background:#b1ffff">遍历链表，寻找指定键</span>
> 
>     while (p->next && p->next->key != key) {
> 
>         p = p->next;
> 
>     }
> 
>     // 如果到达链表末尾仍未找到指定键，则返回 NULL
> 
>     if (p->next == NULL) {
> 
>         return NULL;
> 
>     } else {
> 
>         printf("found\n"); // 找到键后打印确认信息
> 
>         `return p->next; // 返回找到的节点
> 
>     }
> 
> }

# 十一、排序

## 排序的原理
### 1 、排序定义
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646172.png|Open: Pasted image 20250709204821.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646172.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646172.png)

### 2 、内排序方法
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646285.png|Open: Pasted image 20250709204845.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646285.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646285.png)

### 3 、插入排序
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646356.png|Open: Pasted image 20250709204902.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646356.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646356.png)
### 4 、直接插入排序
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646453.png|Open: Pasted image 20250709204928.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646453.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646453.png)

### 5、折半插入排序
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646755.png|Open: Pasted image 20250709205053.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646755.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646755.png)

### 6、链表插入排序
[“九、排序的原理”页上的图片](onenote:#九、排序的原理&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={3FCD39B6-B3B0-495D-848C-78302551DD39}&object-id={04B4CCC3-5B0C-06DF-150E-7CE3C94284BC}&4D&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)


### 7、交换排序
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646883.png|Open: Pasted image 20250709205115.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646883.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646883.png)

### 8、起泡排序
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646959.png|Open: Pasted image 20250709205123.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646959.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171646959.png)


### 9、快速排序
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171647061.png|Open: Pasted image 20250709205132.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171647061.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171647061.png)


## 快速排序的实现
### 1 、思路解析
[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171647134.png|Open: Pasted image 20250709205158.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171647134.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171647134.png)

### 2 、代码分析
[sort.c](onenote:#sort.c&section-id={DB42EB37-E0A8-4904-B775-58E8CE751162}&page-id={4F8DC764-6D1E-48A7-85B9-7A2358727909}&end&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/嵌入式数据结构/嵌入式数据结构.one)

### 3 、



[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171647542.jpg|Open: 1752066815617.jpg]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171647542.jpg](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171647542.jpg)

[[嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648353.png|Open: Pasted image 20250709211439.png]]
![RK3568（linux学习）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648353.png](嵌入式知识学习（通用扩展）（未）/linux基础知识学习/assets/嵌入式数据结构/file-20250810171648353.png)





# 一、SDIO WiFi驱动未能成功创建网络接口 `wlan0`(OK)

根据日志分析，SDIO WiFi驱动未能成功创建网络接口 `wlan0`，导致后续网络配置失败。以下是分步解决方案：


[[wifi驱动调试记录-高拓讯达#报错：加载成功，但是没有生成设备节点，没有识别到mmc1进行配置]]


### **1. 确认SDIO设备枚举状态**
#### **(1) 检查SDIO控制器是否识别设备**
运行以下命令查看内核日志：
```bash
dmesg | grep -i "mmc\|sdio"
```
**期望输出**：
```bash
mmc1: new high-speed SDIO card at address 0001
```
**若无输出**：
<span style="background:#b1ffff">- **硬件问题**：检查SDIO接口的电源、时钟、数据线连接是否正常，确保WiFi模块已正确插入。</span>
- **设备树配置**：确认SDIO控制器节点已启用，例如：
  ```dts
  &usdhc2 {  // SDIO控制器节点
      status = "okay";
      non-removable;
      bus-width = <4>;
      // 其他配置（如中断引脚）需匹配硬件设计
  };
  ```

---

### **2. 验证驱动与设备的绑定**
#### **(1) 检查驱动是否绑定到SDIO设备**
```bash
ls /sys/bus/sdio/drivers/atbm6x3x_wifi_usb/  # 替换为实际驱动名
```
- **若为空**：驱动未绑定设备，需检查：
  - **设备ID匹配**：驱动源码中的 `SDIO_DEVICE_ID` 是否与硬件厂商ID（VID）和设备ID（PID）匹配。
  - **设备树配置**：确保SDIO子节点的 `compatible` 属性与驱动中定义的字符串一致。

#### **(2) 手动触发设备探测**
```bash
echo 1 > /sys/bus/sdio/rescan  # 强制重新扫描SDIO总线
```

---
### **3. 固件加载问题排查**
#### **(1) 确认固件文件路径与权限**
```bash
ls -l /lib/firmware/atbm6031_fw.bin
```
- 确保固件文件存在且权限为 `644`：
  ```bash
  chmod 644 /lib/firmware/atbm6031_fw.bin
  ```

#### **(2) 检查驱动中的固件加载逻辑**
在驱动源码中搜索 `request_firmware` 调用，确保路径和文件名正确：
```c
ret = request_firmware(&fw, "atbm6031_fw.bin", &func->dev);
if (ret) {
    dev_err(&func->dev, "Firmware加载失败: %d\n", ret);
    return ret;
}
```

---

### **4. 中断配置验证**
#### **(1) 设备树中的中断配置**
确认中断引脚（如 `WAKE_HOST`）已正确配置：
```dts
wifi: atbm6031@1 {
    compatible = "atmel,atbm6031-sdio";
    reg = <1>;
    interrupt-parent = <&gpio1>;
    interrupts = <5 IRQ_TYPE_LEVEL_HIGH>;  // 根据实际GPIO和触发类型修改
};
```

#### **(2) 驱动中的中断注册**
在驱动探测函数中，确保中断处理函数已正确注册：
```c
int irq = gpio_to_irq(priv->wake_host_gpio);
ret = request_irq(irq, atbm_interrupt_handler, IRQF_TRIGGER_LOW, "atbm-wifi", priv);
```

---

### **5. cfg80211接口实现检查**
#### **(1) 确保驱动实现关键API**
在驱动源码中，确认 `cfg80211_ops` 结构体已实现以下必要接口：
```c
static struct cfg80211_ops atbm_cfg80211_ops = {
    .scan = atbm_cfg80211_scan,
    .connect = atbm_cfg80211_connect,
    .disconnect = atbm_cfg80211_disconnect,
    .add_key = atbm_cfg80211_add_key,
    .del_key = atbm_cfg80211_del_key,
    .set_default_key = atbm_cfg80211_set_default_key,
    // 其他必需接口...
};
```

#### **(2) 启用内核配置**
<span style="background:#b1ffff">确保内核配置启用了 `cfg80211` 和 `mac80211`：</span>
```bash
CONFIG_CFG80211=y
CONFIG_MAC80211=y
# 可选：启用WEXT兼容层（若驱动依赖旧接口）
CONFIG_CFG80211_WEXT=y
```

---

### **6. 调试与日志分析**
#### **(1) 启用动态调试**
```bash
echo "module atbm6x3x_wifi_usb +p" > /sys/kernel/debug/dynamic_debug/control
dmesg -w  # 实时查看驱动日志
```
关注以下关键信息：
- 固件加载状态
- 中断触发记录
- 网络接口注册结果

#### **(2) 手动测试接口创建**
```bash
ifconfig wlan0 up  # 尝试手动启用接口
iw dev wlan0 scan  # 测试扫描功能
```

---

### **7. 常见问题解决方案**
| **现象**               | **可能原因**                | **解决措施**                          |
|------------------------|---------------------------|--------------------------------------|
| 无`mmc1`设备日志       | SDIO控制器未启用或硬件故障   | 检查设备树、电源、信号完整性            |
| `wlan0`接口未创建      | 驱动未调用`ieee80211_register_hw` | 在驱动probe函数中注册网络设备           |
| `nl80211`不支持操作    | `cfg80211_ops`未实现完整接口 | 补全驱动中的`scan`、`connect`等API     |
| 固件加载超时           | 固件路径错误或权限不足       | 确认`/lib/firmware`路径及文件权限       |

---

### **8. 硬件复位与电源管理**
#### **(1) 复位引脚时序控制**
在驱动初始化阶段，手动触发硬件复位：
```c
// 示例：复位引脚接GPIO1_5，低电平有效
gpio_request_one(5, GPIOF_OUT_INIT_HIGH, "wifi_reset");
gpio_set_value(5, 0);
msleep(50);
gpio_set_value(5, 1);
msleep(200);
```

#### **(2) 电源稳定性检查**
使用示波器测量SDIO接口的3.3V电源，确保在驱动加载过程中无电压跌落。

---

### **总结**
通过上述步骤排查硬件连接、驱动匹配、固件加载、中断配置和协议栈兼容性问题，应能解决 `mmc1` 设备未识别和 `wlan0` 接口创建失败的问题。若仍无法解决，建议联系模块厂商获取最新驱动或调试支持。



# 三、make menuconfig 已经配置好了，但是sdiowifi驱动加载有问题，看一下是设备树那里配置有问题，还是什么其他原因

<span style="background:#affad1"> 驱动源码没配好</span>

1. SDIO 配置问题：
   - 在 `mmc.c` 中，SDIO 配置使用了 `wifi_gpio` 结构体，但其中的 GPIO 引脚配置可能不正确：
     ```c
     static struct card_gpio wifi_gpio = {
         .wp = {GPIO_WLAN_WP, GPIO_MMC_WIFI_RST_N_LEVEL},  // 写保护引脚
         .cd = {GPIO_WLAN_CD, GPIO_MMC_WIFI_RST_N_LEVEL},  // 卡检测引脚
         .pwr = {WLAN_PWR_EN, GPIO_MMC_WIFI_POWER_LEVEL},  // 电源使能引脚
         .rst = {WL_REG_EN, GPIO_MMC_WIFI_RST_N_LEVEL},    // 复位引脚
     };
     ```
   - 需要确保这些 GPIO 引脚的定义和实际硬件连接一致

2. 电源管理问题：
   - 在 `board.h` 中，WiFi 电源相关的配置：
     ```c
     #define WLAN_PWR_EN    GPIO_PA(6)       // WiFi 电源使能引脚
     #define BCM_PWR_EN    (-1)              // BCM 电源使能引脚
     #define GPIO_MMC_WIFI_POWER_LEVEL        1  // WiFi 电源控制有效电平为高
     #define GPIO_MMC_WIFI_RST_N_LEVEL       0   // WiFi 复位有效电平为低
     ```
   - 需要确保电源管理配置正确

<span style="background:#b1ffff">3. 建议的修改步骤：</span>

   a. 修改 `mmc.c` 中的 SDIO 配置：
   ```c
   static struct card_gpio wifi_gpio = {
       .wp = {-1, 0},                    // 写保护引脚未使用
       .cd = {-1, 0},                    // 卡检测引脚未使用
       .pwr = {GPIO_PA(6), 1},           // 使用 PA6 作为电源使能，高电平有效
       .rst = {GPIO_PB(26), 0},          // 使用 PB26 作为复位，低电平有效
   };
   ```

   b. 确保 `board_base.c` 中启用了正确的配置：
   ```c
   #ifdef CONFIG_JZMMC_V12_MMC1
   DEF_DEVICE(&jz_msc1_device, &sdio_pdata, sizeof(struct jzmmc_platform_data)),
   #endif
   ```

   c. 在 menuconfig 中确保以下选项已启用：
   ```
   Device Drivers  --->
     MMC/SD/SDIO card support  --->
       [*] MMC/SD/SDIO card support
       [*]   SDIO support
       [*]   JZ MMC/SD controller support
       [*]     JZ MMC/SD controller for MSC1
   ```

4. 调试建议：
   - 使用 `dmesg` 命令查看内核日志，特别关注 SDIO 和 WiFi 相关的错误信息
   - 检查 `/sys/kernel/debug/mmc1/` 目录下的调试信息
   - 使用示波器或逻辑分析仪检查 SDIO 时钟和数据线
   - 检查 WiFi 模块的电源和复位信号

5. 可能的问题原因：
   - GPIO 配置与实际硬件连接不匹配
   - 电源管理配置不正确
   - SDIO 时钟配置问题
   - WiFi 固件未正确加载
   - 中断配置问题

您需要我帮您执行哪些具体的修改或提供更详细的调试步骤吗？


# 四、 Unknown symbol print_hex_dump_bytes (err 0)


#include <linux/printk.h>  // 提供 print_hex_dump_bytes 的原型
1. **函数声明冲突**：

    extern static inline void print_hex_dump_bytes(...)
    
    - `extern` 和 `static inline` 关键字冲突，二者不能同时使用。
        
    - 内核源码中已存在 `print_hex_dump_bytes` 的实现（位于 `include/linux/printk.h`），此处重复定义。
        
2. **调用链冲突**：
    
    - 代码尝试自定义 `print_hex_dump_bytes`，但<span style="background:#b1ffff">内核已通过 `dynamic_hex_dump` 宏提供了该功能的实现。</span>
        

### **解决方案**

#### **1. 删除自定义的 `print_hex_dump_bytes` 函数**

在 `arch/mips/xburst/soc-t23/chip-t23/isvp/common/mmc.c` 中：

- extern static inline void print_hex_dump_bytes(const char *prefix_str, int prefix_type,
-                      const void *buf, size_t len)
- {
-     dynamic_hex_dump(prefix_str, prefix_type, 16, 1, buf, len, true);
- }

#### **2. 包含正确的头文件**

确保 `mmc.c` 已包含 `printk.h`：



#include <linux/printk.h>  // 提供 print_hex_dump_bytes 的原型
[19_内核模块符号导出](onenote:https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第一期_驱动基础.one#19_内核模块符号导出&section-id={F6EC1735-9AD6-4EB6-B48F-6AFF2AADA112}&page-id={CD74613B-B2CC-4497-90AF-51C66B4FE33A}&end)  ([Web 视图](https://onedrive.live.com/view.aspx?resid=52D4B76BB0FFCF51%21se8c325913f784bf694d429e5ee2ab2be&id=documents&wd=target%28%E7%AC%AC%E4%B8%80%E6%9C%9F_%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80.one%7CF6EC1735-9AD6-4EB6-B48F-6AFF2AADA112%2F19_%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA%7CCD74613B-B2CC-4497-90AF-51C66B4FE33A%2F%29&wdpartid=%7bB58A692A-C91C-477E-9ECF-EBE1A66C5194%7d%7b1%7d&wdsectionfileid=52D4B76BB0FFCF51!sb8d9d2d7954f45f0acc8eb1d4509a9ba))




# 五、测试驱动（atbm6x3x_wifi_usb_fast.ko）

![君正T23N芯片开发/【君正T23N\_IPC】/BSP驱动开发/assets/报错与解决/file-20250810171417849.ko](assets/报错与解决/file-20250810171417849.ko)

- 1 若能加载成功，则证明内核配置没有问题。是自己配的WIFI驱动有问题。


































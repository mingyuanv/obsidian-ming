---
title: 
aliases: 
tags: 
description:
---

# 随记：




# 一、加载成功，但是没有生成设备节点(?????)
[    6.183327] [atbm_log]:platform_init(252)
[    6.187565] [atbm_log]:SVN_VER=34075,DPLL_CLOCK=24,BUILD_TIME=[===== =====]
[    6.197339] [atbm_log]:----drvier RATEPOLCIY=OLD


[[wifi驱动调试记录-高拓讯达#报错：加载成功，但是没有生成设备节点，没有识别到mmc1进行配置]]


# 二、不能卸载驱动


rmmod: can't change directory to '3.10.14__isvp_pike_1.0__': No such file or directory

<span style="background:#b1ffff">该文件系统本身就有问题</span>
<span style="background:#b1ffff">不能实现在串口终端卸载驱动</span>



### **问题原因与解决方案**

---

#### **1. 错误原因分析**
- **关键错误信息**：  
  ```bash
  rmmod: can't change directory to '3.10.14__isvp_pike_1.0__': No such file or directory
  ```
  - **直接原因**：`rmmod` 命令尝试进入内核模块目录 `/lib/modules/$(uname -r)`，但该目录不存在。  
  - **根本原因**：  
    1. 内核模块目录未正确创建（通常由内核编译或模块安装流程不完整导致）。  
    2. 文件系统权限问题（如根文件系统只读或用户无权限访问）。  

---

#### **2. 分步解决方案**
##### **2.1 手动创建缺失的模块目录**
```bash
# 创建内核模块目录（名称与 uname -r 输出一致）
mkdir -p /lib/modules/3.10.14__isvp_pike_1.0__

# 生成模块依赖关系（即使目录为空）
depmod -a

# 重新尝试卸载模块
rmmod atbm6031_wifi_sdio
```

##### **2.2 若目录已存在但权限不足**
```bash
# 检查目录权限
ls -ld /lib/modules/3.10.14__isvp_pike_1.0__

# 赋予读写权限（根据实际用户调整）
chmod 755 /lib/modules/3.10.14__isvp_pike_1.0__
```

##### **2.3 强制卸载模块（跳过依赖检查）**
```bash
# 直接通过模块路径卸载（无需依赖目录）
rmmod -f /path/to/atbm6031_wifi_sdio.ko
# 示例：
rmmod -f /lib/modules/atbm6031_wifi_sdio.ko
```

##### **2.4 修复模块安装流程（编译环境）**
1. **修改内核编译配置**：  
   在编译内核时，确保启用模块目录自动生成：  
   ```bash
   make modules_install INSTALL_MOD_PATH=/target/rootfs
   ```
2. **检查文件系统挂载**：  
   确认目标设备的 `/lib/modules` 目录可写：  
   ```bash
   mount | grep /lib/modules
   # 若为只读，重新挂载为读写：
   mount -o remount,rw /dev/mmcblk0p1 /
   ```

---

#### **3. 验证操作**
1. **检查模块目录状态**：  
   ```bash
   ls /lib/modules/3.10.14__isvp_pike_1.0__  # 应包含 modules.* 文件
   ```
2. **确认模块卸载成功**：  
   ```bash
   lsmod | grep atbm6031_wifi_sdio  # 无输出表示已卸载
   ```

---

#### **4. 常见问题排查**
| **现象**               | **原因**                     | **解决**                          |
|------------------------|-----------------------------|----------------------------------|
| 目录创建后仍报错       | 文件系统只读                 | `mount -o remount,rw /`          |
| 模块卸载后自动重新加载 | 模块被系统服务依赖           | 停止相关服务（如 NetworkManager）|
| 模块路径错误           | 驱动未正确安装到目标设备     | 手动复制模块文件到 `/lib/modules`|

---

#### **5. 总结**
通过创建缺失的内核模块目录或修复权限，即可解决 `rmmod` 的目录错误。若问题持续，需检查内核编译流程和文件系统配置，确保模块管理功能正常。






# 三、`country_chan`参数始终为0
根据日志信息，驱动在尝试扫描2.4GHz频段时，`country_chan`参数始终为0，这表明 **国家/地区代码（Regulatory Domain）未正确设置**，导致无法扫描到合法的WiFi信道。
## 1./hal_apollo/mac80211/main.c
/home/ming/workspace/ATBM_LINUX_WIFI4_BLE_SVN3407_AsmLite19040_ARESM18826_Meru19963_V1.1_20241023/hal_apollo/mac80211/main.c

	}else{
		atbm_printk_err("cfg80211_regdomain is NULL\n");
		local->country_code="CN";
		local->country_support_chan = country_chan_found(local->country_code);
	}


## 2./hal_apollo/mac80211/scan.c

<span style="background:#fdbfff"> 改这个函数即可</span>
/home/ming/workspace/ATBM_LINUX_WIFI4_BLE_SVN3407_AsmLite19040_ARESM18826_Meru19963_V1.1_20241023/hal_apollo/mac80211/scan.c
 * ieee80211_check_country_limit_scan_2_4G_chan - 根据国家或地区法规检查2.4GHz频段的扫描请求限制
 *
 * @local: 指向ieee80211_local结构的指针，包含本地无线设备的信息和状态。
 * @req: 指向cfg80211_scan_request结构的指针，包含一个扫描请求的所有相关信息。
 *
 * 本函数用于根据当前配置的国家代码和地区法规来判断是否允许在2.4GHz频段上进行扫描。如果存在限制，则返回相应的值指示具体的限制类型。
 *
<span style="background:#b1ffff">static int ieee80211_check_country_limit_scan_2_4G_chan</span>(struct ieee80211_local *local,
                                                        struct cfg80211_scan_request *req)

	// 假设 local->country_code 已经被定义为 char 类型的数组，并且大小至少为3（两个字符加上终止符）
	memcpy(local->country_code, "CN", 2); // 复制两个字符 "CN"
	local->country_code[2] = '\0';        // 确保字符串以 null 结尾




## 3.OK
[   11.535872] [atbm_log]:ieee80211_check_country_limit_scan_2_4G_chan : scan_n_channals = 13 --------- 
[   11.545592] [atbm_log]:__ieee80211_start_scan:channels[13]
[   11.563398] [atbm_log]:ieee80211_prep_hw_scan:n_chans(13),space(13),index(13),scaned(13)
[   11.571797] [atbm_log]:atbm_hw_scan:if_id(0)
[   11.576584] [atbm_log]:atbm_hw_scan:scan, delay suspend

 struct country_chan country_t[10]={
	  {"CN",13},
	  {"JP",14},
	  {"US",11},
	  {"EU",13},
	  {NULL,0}
};
#endif


# 四、驱动在处理 **A-MPDU（聚合MAC协议数据单元）** 时触发了特定动作，同时存在 **SDIO中断丢失** 的警告。
```
[root@Ingenic-uc1_1:bin]# [ 847.273324] [atbm_log]:atbm_sdio_irq_period:Miss [ 915.399395] <WIFI> rx ampdu ++ [ 915.423428] [atbm_log]:AMPDU[wlan0]:action[2],tid[0],ssn[11],buff_size[0],token[0],ta[10:82:3d:0c:e9:ea] [ 915.435013] [atbm_log]:AMPDU[wlan0]:action[4],tid[0],ssn[0],buff_size[64],token[0],ta[10:82:3d:0c:e9:ea] [ 920.963322] [atbm_log]:AMPDU[wlan0]:action[2],tid[6],ssn[1],buff_size[0],token[1],ta[10:82:3d:0c:e9:ea] [ 920.976725] [atbm_log]:AMPDU[wlan0]:action[4],tid[6],ssn[0],buff_size[64],token[1],ta[10:82:3d:0c:e9:ea]
```

## 1.循环尝试多次处理丢失的中断（也不完全行）

<span style="background:#affad1">这个办法应该很耗资源。</span>
<span style="background:#d3f8b6">可以，确实减少报错的频率。但有个别的丢失的中断尝试处理30次也不行。</span>
/home/ming/workspace/ATBM_LINUX_WIFI4_BLE_SVN3407_AsmLite19040_ARESM18826_Meru19963_V1.1_20241023<span style="background:#b1ffff">/hal_apollo/apollo_sdio.c</span>

`第347行`
`static int atbm_sdio_irq_period(struct atbm_sdio_thread *thread)`
```
		//注释掉的循环尝试多次处理丢失的中断
		do {
			atbm_sdio_miss_irq(hw_priv->sbus_priv);
			ret = atbm_bh_read_ctrl_reg_unlock(hw_priv, &ctrl_reg);
			atbm_printk_err("%s:Miss %d \n", __func__, retry);
		} while (retry++ < 30 && (ctrl_reg & ATBM_HIFREG_CONT_NEXT_LEN_MASK));

```

<span style="background:#affad1">算了，看来是无法完全解决，有可能是硬件问题。</span>
## 2.中断下文机制(没处理好)
deepseek帮写的，差点意思。开解锁罗辑不行。
```
/* Tasklet处理函数 */
static void mytasklet_func(unsigned long data)
{
    struct atbm_common *hw_priv = (struct atbm_common *)data;
	u16 ctrl_reg = 0;
	int ret = 0;
    int retry = 0;
    const int max_retry = 5; // 最大重试次数限制

	/* 带超时和重试次数的处理机制 */
	do {
		/* 实际的中断恢复处理 */
		atbm_sdio_miss_irq(hw_priv->sbus_priv);

		/* 检查处理结果 */
		ret = atbm_bh_read_ctrl_reg_unlock(hw_priv, &ctrl_reg);

		if (!(ctrl_reg & ATBM_HIFREG_CONT_NEXT_LEN_MASK)) {
			atbm_printk_debug("%s: Cleared after %d retries\n", __func__, retry);
			break;
		}
		/* 调试日志：显示重试状态 */
		atbm_printk_debug("%s: Retry %d, ctrl_reg=0x%04x\n", 
						__func__, retry, ctrl_reg);
	} while (retry++ < max_retry);

	/* 超过最大重试次数的处理 */
	if (retry >= max_retry) {
		atbm_printk_err("%s: Max retries(%d) reached!\n", __func__, max_retry);
		return 0;
	}

	return 1;
}

/**
 * @brief 函数 atbm_sdio_irq_period 用于处理SDIO中断周期。它检查是否有未处理的数据包或丢失的中断，
 * 并根据情况执行相应的操作。如果发现有数据包丢失，则会记录错误日志并尝试处理丢失的中断。
 *
 * @param thread 指向 SDIO 线程结构体的指针，包含线程相关的信息和状态标志
 * @return int 返回值指示是否处理了中断或发生了异常（1表示已处理或发生异常，0表示正常退出）
 */
/* SDIO中断周期处理函数 - 优化版 */
static int atbm_sdio_irq_period(struct atbm_sdio_thread *thread)
{
	struct sbus_priv *self = (struct sbus_priv *)thread->self;
	struct atbm_common *hw_priv = self->core;
    u16 ctrl_reg = 0;
    int ret = 0;
    int retry = 0;
    const int max_retry = 5; // 最大重试次数限制
    ktime_t start_time;

	struct tasklet_struct wifi_tasklet;
	
	tasklet_init(&wifi_tasklet,mytasklet_func,(unsigned long)hw_priv);

    /* 调试日志：记录函数入口时间 */
    start_time = ktime_get();

    /* 仅在实际需要操作时加锁 */
    hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
    
    /* 检查线程终止标志 */
    if (atbm_bh_is_term(hw_priv)) {
        hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
        goto exit;
    }

    /* 检查唤醒标志后立即解锁 */
    if (test_bit(THREAD_WAKEUP, &thread->flags)) {
        hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
        ret = 1;
        goto exit;
    }
    hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);

    /* 读取控制寄存器（无锁版本） */
    ret = atbm_bh_read_ctrl_reg_unlock(hw_priv, &ctrl_reg);
    if (ret) {
        atbm_printk_err("%s: Read ctrl_reg failed(%d)\n", __func__, ret);
        goto exit;
    }


    /* 检查是否有未处理数据 */
    if (ctrl_reg & ATBM_HIFREG_CONT_NEXT_LEN_MASK) {
        __set_current_state(TASK_RUNNING);
        atbm_printk_err("%s: Miss detected\n", __func__);

		/* 调度到下半部处理 */
		tasklet_schedule(&wifi_tasklet);

		return IRQ_RETVAL(IRQ_HANDLED);
    }

exit:
    /* 性能监控：记录处理耗时 */
    atbm_printk_debug("%s: Processing time: %lld ns\n", __func__,
                     ktime_to_ns(ktime_sub(ktime_get(), start_time)));
    return ret;
}


```














## 3.**关键优化点说明**

1. **智能重试机制**：
    - 限制最大重试次数为5次，防止死循环
    - 每次重试后检查控制寄存器状态，成功则提前退出
    - 增加重试状态调试日志
2. **精细化的锁管理**：
```
/* 加锁范围优化示例 */
hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
if (termination_condition) {
    hw_priv->sbus_ops->unlock(hw_priv->sbus_priv); // 立即解锁
    goto exit;
}
hw_priv->sbus_ops->unlock(hw_priv->sbus_priv); // 提前解锁
```

3. **异步任务处理**
    - 使用Tasklet将耗时操作移出中断上下文
    - 确保关键路径最小化
4. **增强的调试支持**：
```
/* 时间戳监控 */
ktime_t start_time = ktime_get();
...
pr_debug("Processing took %lld ns", 
        ktime_to_ns(ktime_sub(ktime_get(), start_time)));

/* 状态跟踪 */
pr_debug("CtrlReg=0x%04x Retry=%d", ctrl_reg, retry);
```
3. **错误边界处理**：
```
if (retry >= max_retry) {
    pr_err("Max retries(%d) reached!", max_retry);
    // 可添加硬件复位等恢复操作
}
```











# 五、#include <linux/interrupt.h>找不到，怎么自己添加

[linux缺少内核头文件linux/init.h时怎么办\_init.h没有那个文件-CSDN博客](https://blog.csdn.net/xujianjun229/article/details/119154487)

## 1.拷呗过来

1.找到系统自带<span style="background:#b1ffff">内核文件 /usr/src里面放的都是内核的源代码和头文件,找到需要的文件,复制到/usr/include里面即可</span>

![](https://i-blog.csdnimg.cn/blog_migrate/1593dd473346a5f296f17f03b71806bc.png)

`sudo cp interrupt.h /usr/include/linux/`

## 2.

 2.去/usr/include/linux里面查看有没有,系统调用头文件,都在/usr/include中

![](https://i-blog.csdnimg.cn/blog_migrate/c40c5783111c0230ddfc0f7368efb41e.png)


## 3.

 3.ok了,可以继续使用了,别的头文件也是这个道理


# 六、


## 1.

## 2.

## 3.














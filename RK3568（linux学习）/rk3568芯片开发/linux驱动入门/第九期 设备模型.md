---
title: 
aliases: 
tags: 
description:
---

# 备注(声明)：
![RK3568（linux学习）/rk3568芯片开发/linux驱动入门/assets/第九期 设备模型/file-20250810171728658.png](assets/第九期%20设备模型/file-20250810171728658.png)


# 一、设备模型基本知识

[[RK3568（linux学习）/驱动子系统思维导图/设备模型的结构体及其定义.canvas|设备模型的框架]]
## kobject和kset
### 1 什么是 kobject（内核对象）（结构体）
[“1.抛砖引玉-设备模型的框架：kobject和kset（网课）”页上的图片](onenote:#1.抛砖引玉-设备模型的框架：kobject和kset（网课）&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={B51E34E4-222F-4676-88F8-C36C38E214E4}&object-id={3FC15CCA-A0E4-445E-B903-BB3B00C282CF}&12&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

![RK3568（linux学习）/rk3568芯片开发/linux驱动入门/assets/第九期 设备模型/file-20250810171728925.png](assets/第九期%20设备模型/file-20250810171728925.png)
### 2 什么是 kset（`kobject`的集合）（结构体）
[“1.抛砖引玉-设备模型的框架：kobject和kset（网课）”页上的图片](onenote:#1.抛砖引玉-设备模型的框架：kobject和kset（网课）&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={B51E34E4-222F-4676-88F8-C36C38E214E4}&object-id={3FC15CCA-A0E4-445E-B903-BB3B00C282CF}&40&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)


// <span style="background:#affad1">嵌入的kobject，使得kset本身也可以像kobject一样被管理和使用</span>
    struct kobject kobj;

### 3 kset和 kobject 的关系
[k set中的这个链表头](onenote:#1.抛砖引玉-设备模型的框架：kobject和kset（网课）&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={B51E34E4-222F-4676-88F8-C36C38E214E4}&object-id={CBA7D10A-8C89-41ED-A804-971068CAD48F}&3E&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
[就会和k object中的entry相连接](onenote:#1.抛砖引玉-设备模型的框架：kobject和kset（网课）&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={B51E34E4-222F-4676-88F8-C36C38E214E4}&object-id={CBA7D10A-8C89-41ED-A804-971068CAD48F}&40&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
[然后不同的key object的entry又会互相的连接到一起](onenote:#1.抛砖引玉-设备模型的框架：kobject和kset（网课）&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={B51E34E4-222F-4676-88F8-C36C38E214E4}&object-id={CBA7D10A-8C89-41ED-A804-971068CAD48F}&42&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

![RK3568（linux学习）/rk3568芯片开发/linux驱动入门/assets/第九期 设备模型/file-20250810171729079.png](assets/第九期%20设备模型/file-20250810171729079.png)

### 4 kset和 kobject 的关系总结
[“1.抛砖引玉-设备模型的框架：kobject和kset(文档)”页上的图片](onenote:#1.抛砖引玉-设备模型的框架：kobject和kset\(文档\)&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={C4381CE4-BB8B-4A41-9034-D478495C2EAD}&object-id={4AEAD227-75CF-4EB6-8A85-BA9A9E33B30F}&A7&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 5、




## 设备模型的引入
<span style="background:#affad1">用设备模型来编写linux驱动</span>

<span style="background:#affad1">有kobject的成员一般会形成目录。</span>

[[RK3568（linux学习）/驱动子系统思维导图/设备模型的结构体及其定义.canvas|设备模型的框架]]
### 1 设备模型的作用- 做好设备驱动的管理
[“4.什么是设备模型，为什么要引入设备模型？”页上的图片](onenote:#4.什么是设备模型，为什么要引入设备模型？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={95EE232B-30F6-4EE5-A511-3EE94BD275E5}&object-id={C6209CA2-CFF7-4053-91B8-BC43A2054B84}&3E&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

使用设备模型来编写linux驱动，好处它是显而易见的
而且非常的简单，因为<span style="background:#affad1">它已经给我们抽象出来了，现成的数据结构和接口</span>
<span style="background:#affad1">我们编写去用的时候，只需要无脑的去填充数据结构就可以了</span>

### 2 设备模型包含总线，设备，驱动和类四个概念。
[“4.什么是设备模型，为什么要引入设备模型？”页上的图片](onenote:#4.什么是设备模型，为什么要引入设备模型？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={95EE232B-30F6-4EE5-A511-3EE94BD275E5}&object-id={C6209CA2-CFF7-4053-91B8-BC43A2054B84}&3E&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)


- **举例**
[“4.什么是设备模型，为什么要引入设备模型？”页上的图片](onenote:#4.什么是设备模型，为什么要引入设备模型？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={95EE232B-30F6-4EE5-A511-3EE94BD275E5}&object-id={C6209CA2-CFF7-4053-91B8-BC43A2054B84}&52&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
### 3 描述总线的结构体 - bus_type
[我们直接用就可以了](onenote:#4.什么是设备模型，为什么要引入设备模型？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={95EE232B-30F6-4EE5-A511-3EE94BD275E5}&object-id={608EEF6D-320B-440D-A99A-1FD2EFA73A07}&11&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
[也就是我们直接去填充相关的结构体](onenote:#4.什么是设备模型，为什么要引入设备模型？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={95EE232B-30F6-4EE5-A511-3EE94BD275E5}&object-id={608EEF6D-320B-440D-A99A-1FD2EFA73A07}&13&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)


### 4 描述设备的结构体 - device
[使用device](onenote:#4.什么是设备模型，为什么要引入设备模型？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={95EE232B-30F6-4EE5-A511-3EE94BD275E5}&object-id={EB9ABB15-7671-05F5-26B2-840B55A5112E}&64&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 5、描述驱动的结构体 - device_driver
[吏用来描述驱动device_driver](onenote:#4.什么是设备模型，为什么要引入设备模型？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={95EE232B-30F6-4EE5-A511-3EE94BD275E5}&object-id={58BEA0C8-F3EF-0179-21B7-530827F7CF47}&10&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 6、描述类的结构体 - class
[描述类的结构体 - class](onenote:#4.什么是设备模型，为什么要引入设备模型？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={95EE232B-30F6-4EE5-A511-3EE94BD275E5}&object-id={58BEA0C8-F3EF-0179-21B7-530827F7CF47}&27&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 7、






## kobject和kset 是设备模型的基本框架
### 1 sysfs 文件系统的作用
[sysfs 文件系统的作用](onenote:#5.对设备模型进一步探究&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={C7534CC5-0CEA-4411-8620-51CE51F91063}&object-id={55B9432F-A0EB-0CDB-2012-AC120DA47D52}&14&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

而s y s fs文件系统的作用是，可以<span style="background:#d3f8b6">把设备模型的组织层次，在用户空间展示给用户</span>。
### 2 kobject嵌入其他结构体
[“5.对设备模型进一步探究”页上的图片](onenote:#5.对设备模型进一步探究&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={C7534CC5-0CEA-4411-8620-51CE51F91063}&object-id={4E0D346C-6C6F-4E6B-950A-3DD4CF39927C}&16&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

![RK3568（linux学习）/rk3568芯片开发/linux驱动入门/assets/第九期 设备模型/file-20250810171729184.png](assets/第九期%20设备模型/file-20250810171729184.png)
### 3 追踪代码探究- 当创建 kobject 的时候，父节点为 NULL,，会在系统根目录/sys 目录下创建呢
[就依靠Kobj找路径](onenote:#5.对设备模型进一步探究&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={C7534CC5-0CEA-4411-8620-51CE51F91063}&object-id={5AF24DD0-C4C4-4249-B50D-89888F7CD4F2}&45&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)


### 4 总结出kobject 创建目录的规律
[为什么k o b j和kset 是设备模型的基本框架](onenote:#5.对设备模型进一步探究&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={C7534CC5-0CEA-4411-8620-51CE51F91063}&object-id={5AF24DD0-C4C4-4249-B50D-89888F7CD4F2}&90&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)



## sysfs虚拟文件系统的目录层次分析
### 1 /sys/devices - 连接到总线的全部设备
[“6.sysfs虚拟文件系统的目录层次分析”页上的图片](onenote:#6.sysfs虚拟文件系统的目录层次分析&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={BFA40C4A-E0C9-4179-9073-CE7E31BE8FEF}&object-id={283BFFBB-2231-4441-BF09-D0932AF3B0DB}&20&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 /sys/bus - Linux系统支持并且已经注册的总线
[“6.sysfs虚拟文件系统的目录层次分析”页上的图片](onenote:#6.sysfs虚拟文件系统的目录层次分析&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={BFA40C4A-E0C9-4179-9073-CE7E31BE8FEF}&object-id={283BFFBB-2231-4441-BF09-D0932AF3B0DB}&47&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 /sys/class - 对设备进行归类。
[以这些目录下的目录它实际上都是软连接](onenote:#6.sysfs虚拟文件系统的目录层次分析&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={BFA40C4A-E0C9-4179-9073-CE7E31BE8FEF}&object-id={11787250-93F4-43FB-811A-D77F3E6AD5EB}&1C&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 4 sys目录层次图解
![RK3568（linux学习）/rk3568芯片开发/linux驱动入门/assets/第九期 设备模型/file-20250810171729368.png](assets/第九期%20设备模型/file-20250810171729368.png)

### 5、

## 引用计数器(kref)
### 1 引用计数器的定义
[“7.什么是引用计数器(kref)？”页上的图片](onenote:#7.什么是引用计数器\(kref\)？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={F0F5711E-CB6D-4F72-B48F-93E80E30DB68}&object-id={BA221659-7AA8-45B4-8984-7CA397492209}&15&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 结构体kref的介绍
[“7.什么是引用计数器(kref)？”页上的图片](onenote:#7.什么是引用计数器\(kref\)？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={F0F5711E-CB6D-4F72-B48F-93E80E30DB68}&object-id={BA221659-7AA8-45B4-8984-7CA397492209}&1F&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

<span style="background:#d3f8b6">一般被嵌入进其他结构中来使用</span>
### 3 常用 api 函数
[“7.什么是引用计数器(kref)？”页上的图片](onenote:#7.什么是引用计数器\(kref\)？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={F0F5711E-CB6D-4F72-B48F-93E80E30DB68}&object-id={BA221659-7AA8-45B4-8984-7CA397492209}&58&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 4 

## 探究 - kobject是如何释放的

<span style="background:#affad1">当引用计数器变成0的时候，会去执行release函数。</span>
<span style="background:#affad1">最终调用的释放函数是在 kobj_type 结构体中定义</span>

### 1 创建 kobj 方法一：不用手动去申请内存

[“9.实例：kobject是如何释放的”页上的图片](onenote:#9.实例：kobject是如何释放的&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={37AE8BEB-5605-4082-99DE-B246DA2B3B06}&object-id={04C5C820-31D6-445C-A77B-7F68DFC81CD8}&16&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
### 2 创建 kobj 方法二：需要自己去申请内存并且实现 kobj_type结构体
[“9.实例：kobject是如何释放的”页上的图片](onenote:#9.实例：kobject是如何释放的&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={37AE8BEB-5605-4082-99DE-B246DA2B3B06}&object-id={04C5C820-31D6-445C-A77B-7F68DFC81CD8}&23&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 追踪代码得知- <span style="background:#affad1">最终调用的释放函数是在 kobj_type 结构体中定义</span>
[“9.实例：kobject是如何释放的”页上的图片](onenote:#9.实例：kobject是如何释放的&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={37AE8BEB-5605-4082-99DE-B246DA2B3B06}&object-id={04C5C820-31D6-445C-A77B-7F68DFC81CD8}&2C&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

- **结论**
[“9.实例：kobject是如何释放的”页上的图片](onenote:#9.实例：kobject是如何释放的&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={37AE8BEB-5605-4082-99DE-B246DA2B3B06}&object-id={04C5C820-31D6-445C-A77B-7F68DFC81CD8}&54&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 4 释放函数做了哪些事情
[“9.实例：kobject是如何释放的”页上的图片](onenote:#9.实例：kobject是如何释放的&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={37AE8BEB-5605-4082-99DE-B246DA2B3B06}&object-id={04C5C820-31D6-445C-A77B-7F68DFC81CD8}&75&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

<span style="background:#affad1">对创建的 kobj 进行了释放</span>

### 5、引入并完善kobj_type结构体
[10.引入并完善kobj_type结构体](onenote:#10.引入并完善kobj_type结构体&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={1A5F6349-0CE6-4FA1-80EE-C91C0557E352}&end&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)









# 二、基础知识实践

## 创建kobject实验
### 1 动态创建一个结构体kobject并注册到sysfs的函数
[“2.实践：创建kobject实验”页上的图片](onenote:#2.实践：创建kobject实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={9C0BEC4A-9204-4A1D-930A-FEF96C12C4C6}&object-id={59F375CB-65C1-4BEA-8506-F403FD9A3961}&16&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 kzalloc分配内存函数
[* kzalloc分配内存。内存设置为零。](onenote:#2.实践：创建kobject实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={9C0BEC4A-9204-4A1D-930A-FEF96C12C4C6}&object-id={59F375CB-65C1-4BEA-8506-F403FD9A3961}&4C&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 kobject初始化函数
[* kobject_初始化_和_*](onenote:#2.实践：创建kobject实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={9C0BEC4A-9204-4A1D-930A-FEF96C12C4C6}&object-id={59F375CB-65C1-4BEA-8506-F403FD9A3961}&6B&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

[所以这个参数我们不能写成n u l l](onenote:#2.实践：创建kobject实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={9C0BEC4A-9204-4A1D-930A-FEF96C12C4C6}&object-id={E07F8D48-69F8-4A65-A550-FCB501A2F93B}&37&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 4 kobject释放函数
[* kobject_为对象添加减量折算。](onenote:#2.实践：创建kobject实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={9C0BEC4A-9204-4A1D-930A-FEF96C12C4C6}&object-id={59F375CB-65C1-4BEA-8506-F403FD9A3961}&98&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 5、实验代码编写及现象
[“2.实践：创建kobject实验”页上的图片](onenote:#2.实践：创建kobject实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={9C0BEC4A-9204-4A1D-930A-FEF96C12C4C6}&object-id={59F375CB-65C1-4BEA-8506-F403FD9A3961}&A9&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 6、


## 创建kset实验

### 1 动态创建一个结构体kset并将其添加到sysfs中的函数
[* kset_create_and_add - 动态创建一个结构体kset并将其添加到sysfs中 * *](onenote:#3.实践：创建kset实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={DC094264-880C-42EB-9CFB-40F756DC3450}&object-id={AA0AD891-72D3-4013-A20E-0A0B39B2F885}&48&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 将kobject和我们创建的kset关联起来
[“3.实践：创建kset实验”页上的图片](onenote:#3.实践：创建kset实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={DC094264-880C-42EB-9CFB-40F756DC3450}&object-id={AA0AD891-72D3-4013-A20E-0A0B39B2F885}&A0&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 实验代码编写及现象
[kset.c](onenote:#3.实践：创建kset实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={DC094264-880C-42EB-9CFB-40F756DC3450}&object-id={AA0AD891-72D3-4013-A20E-0A0B39B2F885}&AE&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

![RK3568（linux学习）/rk3568芯片开发/linux驱动入门/assets/第九期 设备模型/file-20250810171729516.png](assets/第九期%20设备模型/file-20250810171729516.png)

### 4 实验现象原因分析
[那此时是不是就将我们创建的这个kset](onenote:#3.实践：创建kset实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={DC094264-880C-42EB-9CFB-40F756DC3450}&object-id={0A2C5E00-37CB-43B6-B1AB-237465AF73F1}&42&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
[里面的k o b j作为了父节点](onenote:#3.实践：创建kset实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={DC094264-880C-42EB-9CFB-40F756DC3450}&object-id={0A2C5E00-37CB-43B6-B1AB-237465AF73F1}&44&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 5、





## 引用计数器实验
### 1 实验代码编写及现象
[“8.实践：引用计数器实验”页上的图片](onenote:#8.实践：引用计数器实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={4A727808-658D-48A8-B8DB-5C5229B458DF}&object-id={B6B9EC32-BCEF-47AB-AFA6-BB1F6F637210}&35&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 实验总结

[“8.实践：引用计数器实验”页上的图片](onenote:#8.实践：引用计数器实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={4A727808-658D-48A8-B8DB-5C5229B458DF}&object-id={B6B9EC32-BCEF-47AB-AFA6-BB1F6F637210}&2E&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

<span style="background:#affad1">子目录被引用一次，所以它的引用计数器的值也要加一</span>。

### 3 引用计数器使用场景
[所以对这个释放顺序是有要求的](onenote:#8.实践：引用计数器实验&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={4A727808-658D-48A8-B8DB-5C5229B458DF}&object-id={B6B9EC32-BCEF-47AB-AFA6-BB1F6F637210}&AD&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 4 



## 在sys目录下创建属性文件并实现读写功能
### 1 封装kobject结构体和属性文件
[“11.在sys目录下创建属性文件并实现读写功能”页上的图片](onenote:#11.在sys目录下创建属性文件并实现读写功能&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={044317A7-F73B-487D-8773-1EEF3E9E221B}&object-id={20D6FA68-E014-47E3-B1D6-053BA360E2DE}&15&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 完善kobj_type中的default_attrs成员

[“11.在sys目录下创建属性文件并实现读写功能”页上的图片](onenote:#11.在sys目录下创建属性文件并实现读写功能&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={044317A7-F73B-487D-8773-1EEF3E9E221B}&object-id={20D6FA68-E014-47E3-B1D6-053BA360E2DE}&32&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
如何使用多个属性的吗，我们是不是<span style="background:#affad1">定义了一个指针数组</span>


<span style="background:#d3f8b6">指向一个属性数组的指针，列出了这个kobject类型的默认属性。</span>

### 3 完善kobj_type中的sysfs_ops成员
[“11.在sys目录下创建属性文件并实现读写功能”页上的图片](onenote:#11.在sys目录下创建属性文件并实现读写功能&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={044317A7-F73B-487D-8773-1EEF3E9E221B}&object-id={20D6FA68-E014-47E3-B1D6-053BA360E2DE}&38&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

  <span style="background:#affad1">指向sysfs操作函数表的指针，定义了如何读写kobject的属性。</span>

### 4 实验现象
[“11.在sys目录下创建属性文件并实现读写功能”页上的图片](onenote:#11.在sys目录下创建属性文件并实现读写功能&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={044317A7-F73B-487D-8773-1EEF3E9E221B}&object-id={20D6FA68-E014-47E3-B1D6-053BA360E2DE}&5B&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)




## 优化sys目录下属性文件的读写函数

- 1 核心代码就是使用kobj_attribute结构体，这样就可以实现一个attribute对应自己的读写函数
### 1 把属性文件和对应的读写函数封装在一起（非sysfs_ops成员）
[“12.优化sys目录下属性文件的读写函数”页上的图片](onenote:#12.优化sys目录下属性文件的读写函数&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={A05594ED-E343-49DD-8D18-B4E0133D886B}&object-id={DA72BD25-B319-437B-AD27-335F0EA56933}&12&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 完善属性文件对应的读写函数
[“12.优化sys目录下属性文件的读写函数”页上的图片](onenote:#12.优化sys目录下属性文件的读写函数&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={A05594ED-E343-49DD-8D18-B4E0133D886B}&object-id={26DCF66F-A724-4110-B2BF-E62C393B4E7C}&21&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 实现sysfs_ops中读写函数引导执行属性文件对应的读写函数
[我们创建的属性对应的kobj_attribute](onenote:#12.优化sys目录下属性文件的读写函数&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={A05594ED-E343-49DD-8D18-B4E0133D886B}&object-id={26DCF66F-A724-4110-B2BF-E62C393B4E7C}&83&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 4  实验现象
[“12.优化sys目录下属性文件的读写函数”页上的图片](onenote:#12.优化sys目录下属性文件的读写函数&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={A05594ED-E343-49DD-8D18-B4E0133D886B}&object-id={26DCF66F-A724-4110-B2BF-E62C393B4E7C}&9E&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

![RK3568（linux学习）/linux开发资料库/代码库/04\_Linux驱动程序/71\_attr02优化sys目录下属性文件的读写函数/module/attr.c](../../linux开发资料库/代码库/04_Linux驱动程序/71_attr02优化sys目录下属性文件的读写函数/module/attr.c)

## 内核帮我们做好kobj_type这个结构体

- ？ 所以在我们的驱动代码中，是不是不用再加release函数了呀
### 1 直接创建属性文件
[“13.在sys目录下创建属性文件并实现读写功能（二）”页上的图片](onenote:#13.在sys目录下创建属性文件并实现读写功能（二）&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={1AAFD62F-92D9-4823-941E-34216B7890E2}&object-id={7DC94D83-3A22-4E4B-8C7A-5E59EC2E7AB5}&14&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 把属性文件和对应的读写函数封装在一起（非sysfs_ops成员）
[“13.在sys目录下创建属性文件并实现读写功能（二）”页上的图片](onenote:#13.在sys目录下创建属性文件并实现读写功能（二）&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={1AAFD62F-92D9-4823-941E-34216B7890E2}&object-id={7DC94D83-3A22-4E4B-8C7A-5E59EC2E7AB5}&1A&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 内核帮我们做好kobj_type这个结构体
[当我们直接调用这个函数的时候，内核帮我们做好kobj type这个结构体，并且在他后面对应的读写函数中的操作和我们上一 节写的是一样的，都是执行属性对应的那个读写函数](onenote:#13.在sys目录下创建属性文件并实现读写功能（二）&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={1AAFD62F-92D9-4823-941E-34216B7890E2}&object-id={7DC94D83-3A22-4E4B-8C7A-5E59EC2E7AB5}&67&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 4 实验现象
[“13.在sys目录下创建属性文件并实现读写功能（二）”页上的图片](onenote:#13.在sys目录下创建属性文件并实现读写功能（二）&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={1AAFD62F-92D9-4823-941E-34216B7890E2}&object-id={7DC94D83-3A22-4E4B-8C7A-5E59EC2E7AB5}&2F&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

![RK3568（linux学习）/linux开发资料库/代码库/04\_Linux驱动程序/72\_attr03\_在sys目录下创建属性文件并实现读写功能（二）/module/attr.c](../../linux开发资料库/代码库/04_Linux驱动程序/72_attr03_在sys目录下创建属性文件并实现读写功能（二）/module/attr.c)

## 在sys目录下创建多个属性文件的简便方法
### 1 属性组- attribute_group的定义
[我们要把创建的所有属性都放到这个组里面](onenote:#14.在sys目录下创建多个属性文件的简便方法&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={714120D7-CC06-4FCC-8808-946B425A19FA}&object-id={B091844D-37B3-48ED-BA07-EDAA9F6037FD}&7E&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 创建属性组
[“14.在sys目录下创建多个属性文件的简便方法”页上的图片](onenote:#14.在sys目录下创建多个属性文件的简便方法&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={714120D7-CC06-4FCC-8808-946B425A19FA}&object-id={B091844D-37B3-48ED-BA07-EDAA9F6037FD}&43&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 实验现象
[“14.在sys目录下创建多个属性文件的简便方法”页上的图片](onenote:#14.在sys目录下创建多个属性文件的简便方法&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={714120D7-CC06-4FCC-8808-946B425A19FA}&object-id={B091844D-37B3-48ED-BA07-EDAA9F6037FD}&78&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
### 4 若没有给这个属性组起名字
[那你创建的这些属性](onenote:#14.在sys目录下创建多个属性文件的简便方法&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={714120D7-CC06-4FCC-8808-946B425A19FA}&object-id={B091844D-37B3-48ED-BA07-EDAA9F6037FD}&98&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
[都会直接在这个目录下去创建](onenote:#14.在sys目录下创建多个属性文件的简便方法&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={714120D7-CC06-4FCC-8808-946B425A19FA}&object-id={B091844D-37B3-48ED-BA07-EDAA9F6037FD}&9A&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)


![RK3568（linux学习）/linux开发资料库/代码库/04\_Linux驱动程序/73\_attr04\_在sys目录下创建多个属性文件的简便方法/module/attr.c](../../linux开发资料库/代码库/04_Linux驱动程序/73_attr04_在sys目录下创建多个属性文件的简便方法/module/attr.c)


# 三、总线实验

## 实践：注册一个自己的总线
### 1 bus_type结构体关键成员的讲解
[“15.实践：注册一个自己的总线”页上的图片](onenote:#15.实践：注册一个自己的总线&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={8317A3E4-1CB2-4295-B197-DF657B15A8A4}&object-id={5C83A11C-A1E3-4420-AC6F-8CF27BACF9E0}&34&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 device结构体中的device_driver结构体
[“15.实践：注册一个自己的总线”页上的图片](onenote:#15.实践：注册一个自己的总线&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={8317A3E4-1CB2-4295-B197-DF657B15A8A4}&object-id={5C83A11C-A1E3-4420-AC6F-8CF27BACF9E0}&4A&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

- 2 设备结构体中的这个成员，代表的就是我现在这个设备对应的设备驱动

### 3 总线注册相关 API函数
[“15.实践：注册一个自己的总线”页上的图片](onenote:#15.实践：注册一个自己的总线&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={8317A3E4-1CB2-4295-B197-DF657B15A8A4}&object-id={5C83A11C-A1E3-4420-AC6F-8CF27BACF9E0}&5C&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 4 实验代码编写及现象
[“15.实践：注册一个自己的总线”页上的图片](onenote:#15.实践：注册一个自己的总线&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={8317A3E4-1CB2-4295-B197-DF657B15A8A4}&object-id={5C83A11C-A1E3-4420-AC6F-8CF27BACF9E0}&B3&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

- 1 它在sys/bus/mybus下自动给我们创建了两个文件夹，分别是device和drivers，另外还有三个属性文件


### 5、



## 在总线目录下创建属性文件

- 1 我们在总线目录下创建属性文件有什么意义呢，属性文件可以实现用户空间和内核空间，的信息交换。
### 1 bus_create_file函数
[它实际上就是我们之前在目录下创建属性文件](onenote:#16.实践：在总线目录下创建属性文件&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={BE963506-A86D-40AB-A528-163A1B41A61D}&object-id={B43A5E26-5860-40CB-8637-EBF7010AB513}&B0&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
[使用的cfs create file这个函数的封装](onenote:#16.实践：在总线目录下创建属性文件&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={BE963506-A86D-40AB-A528-163A1B41A61D}&object-id={B43A5E26-5860-40CB-8637-EBF7010AB513}&B2&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 bus_attribute结构体
[它是不是也是我们之前讲的这个宏定义的](onenote:#16.实践：在总线目录下创建属性文件&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={BE963506-A86D-40AB-A528-163A1B41A61D}&object-id={B43A5E26-5860-40CB-8637-EBF7010AB513}&F6&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
[进一步的封装呀](onenote:#16.实践：在总线目录下创建属性文件&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={BE963506-A86D-40AB-A528-163A1B41A61D}&object-id={B43A5E26-5860-40CB-8637-EBF7010AB513}&F8&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 实验代码编写及现象
[“16.实践：在总线目录下创建属性文件”页上的图片](onenote:#16.实践：在总线目录下创建属性文件&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={BE963506-A86D-40AB-A528-163A1B41A61D}&object-id={B43A5E26-5860-40CB-8637-EBF7010AB513}&7D&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
### 4 


## 实践：在自己的总线下注册设备
### 1 导出bus_type结构体，便于device结构体调用。
[我们使用这个宏定义将他的这个符号导出出来](onenote:#19.实践：在自己的总线下注册设备&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={0088B08B-970D-43EE-94B5-E44F638A4111}&object-id={06C30AB5-2D01-494A-876F-F64DC1963727}&8F&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

- 1 我们要把my_bus这个符号导出出来，我们就可以在device.c这个文件中去使用

### 2 实验代码编写及现象
[“19.实践：在自己的总线下注册设备”页上的图片](onenote:#19.实践：在自己的总线下注册设备&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={0088B08B-970D-43EE-94B5-E44F638A4111}&object-id={06C30AB5-2D01-494A-876F-F64DC1963727}&4F&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 


## 实践：在自己的总线下注册驱动
### 1 实验代码编写及现象
[“23.实践：在自己的总线下注册驱动”页上的图片](onenote:#23.实践：在自己的总线下注册驱动&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={6824F1B7-4322-4319-85AA-4154F552DB71}&object-id={620FE4D5-0900-408B-90F5-9B935F091D06}&16&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 


# 四、总线注册分析-追踪代码分析
[[RK3568（linux学习）/驱动子系统思维导图/设备模型的结构体及其定义.canvas|设备模型的框架]]
## 理论分析：总线是如何注册的？
### 1 kobject一般嵌入到其他结构体中去使用
[“17.理论分析：总线是如何注册的？”页上的图片](onenote:#17.理论分析：总线是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={6AC3BF79-CEC7-47CD-9F04-EF2A397F1572}&object-id={D25C1C1F-B922-401D-A44F-FF2BECC553E4}&33&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 `struct subsys_private`结构体定义
[“17.理论分析：总线是如何注册的？”页上的图片](onenote:#17.理论分析：总线是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={6AC3BF79-CEC7-47CD-9F04-EF2A397F1572}&object-id={D25C1C1F-B922-401D-A44F-FF2BECC553E4}&3C&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)


- 1 通常表示当前注册的总线所示的子系统的私有数据

### 3 新的概念:子系统
[“17.理论分析：总线是如何注册的？”页上的图片](onenote:#17.理论分析：总线是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={6AC3BF79-CEC7-47CD-9F04-EF2A397F1572}&object-id={D25C1C1F-B922-401D-A44F-FF2BECC553E4}&53&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)


### 4 追踪bus_register函数代码分析
[“17.理论分析：总线是如何注册的？”页上的图片](onenote:#17.理论分析：总线是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={6AC3BF79-CEC7-47CD-9F04-EF2A397F1572}&object-id={D25C1C1F-B922-401D-A44F-FF2BECC553E4}&72&base-path=https://d.docs.live.net/52D4B76BB0FFCF51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 5、再次深入体会
[“17.理论分析：总线是如何注册的？”页上的图片](onenote:#17.理论分析：总线是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={6AC3BF79-CEC7-47CD-9F04-EF2A397F1572}&object-id={D25C1C1F-B922-401D-A44F-FF2BECC553E4}&E8&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

- 1 深入体会到了属性文件的作用。
- 1 那这节课呢我建议大家自己把这个bus register，这个函数你自己去分析一下。

### 6、




## 实例分析：platform总线是如何注册的？

### 1 在drivers/base/platfomm.c文件中注册了 platform 总线
[“18.实例分析：platform总线是如何注册的？”页上的图片](onenote:#18.实例分析：platform总线是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={5E4D6F4B-FA70-41F7-85AF-EF4199C7AEF5}&object-id={439CDD6C-6874-440D-8695-DAF69B7CF2E2}&12&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)


### 2 platform总线结构体platform_bus_type
[“18.实例分析：platform总线是如何注册的？”页上的图片](onenote:#18.实例分析：platform总线是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={5E4D6F4B-FA70-41F7-85AF-EF4199C7AEF5}&object-id={439CDD6C-6874-440D-8695-DAF69B7CF2E2}&2A&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)


### 3 platform_match 函数决定总线匹配优先级

[为什么of match table的优先级它是最高的了呀](onenote:#18.实例分析：platform总线是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={5E4D6F4B-FA70-41F7-85AF-EF4199C7AEF5}&object-id={439CDD6C-6874-440D-8695-DAF69B7CF2E2}&97&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
[因为他的这个if判断在最前面吧](onenote:#18.实例分析：platform总线是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={5E4D6F4B-FA70-41F7-85AF-EF4199C7AEF5}&object-id={439CDD6C-6874-440D-8695-DAF69B7CF2E2}&99&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)


- 1 of_match_table>id_table>name
- 1 获取对应的 platform_device 和 platform_driver
### 4 设备模型结构体嵌套在platfrom的结构体中
[因为它要把高级对象接入到设备模型里面](onenote:#18.实例分析：platform总线是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={5E4D6F4B-FA70-41F7-85AF-EF4199C7AEF5}&object-id={439CDD6C-6874-440D-8695-DAF69B7CF2E2}&7D&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
[你比如说这里他就把planet from接到了设备模型里面](onenote:#18.实例分析：platform总线是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={5E4D6F4B-FA70-41F7-85AF-EF4199C7AEF5}&object-id={439CDD6C-6874-440D-8695-DAF69B7CF2E2}&7F&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)





## 理论分析：设备是如何注册的？
### 1 来解析device_register函数，跟踪代码。
[“20.理论分析：设备是如何注册的？”页上的图片](onenote:#20.理论分析：设备是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={3F0DD551-6297-46BF-B125-4DDB34144946}&object-id={7C0CB3A8-6FD4-49DA-B260-D0299ED1E81E}&11&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 总结
[我们需要调用device_register函数](onenote:#20.理论分析：设备是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={3F0DD551-6297-46BF-B125-4DDB34144946}&object-id={7C0CB3A8-6FD4-49DA-B260-D0299ED1E81E}&BF&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

- 1 这个函数它可以分成两个部分
- 1 一个部分是对数据结构进行初始化，另外一个部分是将我们的设备添加进去

### 3 


## 实例分析：platform总线上的设备是如何注册的？
### 1 platform_device_add函数分析-跟踪代码。
[“21.实例分析：platform总线上的设备是如何注册的？”页上的图片](onenote:#21.实例分析：platform总线上的设备是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={D8291A83-98D1-48E4-8B6D-2AEC5297AF4E}&object-id={0214EAFB-96B0-4DBC-8F21-2C9BCF51BAF5}&2A&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

- 1 但是本质上它还是会调用device register，这个api函数，把设备添加到总线当中

### 2 



## 课后作业：为什么在注册platform总线之前先注册了设备？
### 1 在注册platform总线之前先注册了设备？
[“22.课后作业：为什么在注册platform总线之前先注册了设备？”页上的图片](onenote:#22.课后作业：为什么在注册platform总线之前先注册了设备？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={7889BE80-C889-43E2-A559-E9B4F6FD46B5}&object-id={1276B7E0-62C8-40A2-96AA-A1F4EE5B84B1}&18&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 实际现象
[“22.课后作业：为什么在注册platform总线之前先注册了设备？”页上的图片](onenote:#22.课后作业：为什么在注册platform总线之前先注册了设备？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={7889BE80-C889-43E2-A559-E9B4F6FD46B5}&object-id={1276B7E0-62C8-40A2-96AA-A1F4EE5B84B1}&30&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 原因解析
[“22.课后作业：为什么在注册platform总线之前先注册了设备？”页上的图片](onenote:#22.课后作业：为什么在注册platform总线之前先注册了设备？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={7889BE80-C889-43E2-A559-E9B4F6FD46B5}&object-id={1276B7E0-62C8-40A2-96AA-A1F4EE5B84B1}&3A&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

- 1 为什么他会在注册总线之前来注册一个设备（platfrom_bus），注册的这个设备是要作为父设备。
- 1 其他的platform设备呢，都会在这个父目录下去创建子目录

### 4 



## 理论分析：驱动是如何注册的？
### 1 driver_register函数分析-跟踪代码。
[“24.理论分析：驱动是如何注册的？”页上的图片](onenote:#24.理论分析：驱动是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={3057031A-41E1-4D0C-9D90-A52A65D3DB64}&object-id={D15E98D2-ADF0-4602-8AF1-C8E24D4786AF}&1E&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

- 1 所以这个函数的核心函数是不是就是bus_add_driver这个函数

### 2 


## probe函数是如何执行的？
### 1 结论
[如果总线下存在power本函数](onenote:#25.probe函数是如何执行的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={1E8E5DBD-1EA9-4BE4-BBB6-A5A837A128C5}&object-id={0C5E388E-506B-467E-A05B-5CA42D266761}&69&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

- 1 如果总线下存在power本函数，就会去执行总线下的power本函数
- 1 如果我们总线下不存在pob函数，就会去执行驱动中的power b函数
- 1 如果两个pop函数都存在，它是不是先去执行总线下的proper函数，再调用了驱动下的probe函数执行

### 2 继续跟踪bus_add_driver函数分析
[“25.probe函数是如何执行的？”页上的图片](onenote:#25.probe函数是如何执行的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={1E8E5DBD-1EA9-4BE4-BBB6-A5A837A128C5}&object-id={0C5E388E-506B-467E-A05B-5CA42D266761}&20&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 函数调用关系:
[真正的probe函数](onenote:#25.probe函数是如何执行的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={1E8E5DBD-1EA9-4BE4-BBB6-A5A837A128C5}&object-id={0C5E388E-506B-467E-A05B-5CA42D266761}&4E&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)


### 4 


## 为什么加载设备和加载驱动没有先后顺序
- 1 自己一定要养成自己分析问题
- [26.为什么加载设备和加载驱动没有先后顺序](onenote:#26.为什么加载设备和加载驱动没有先后顺序&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={3E027B54-23DD-486C-87F0-9AEF2962EB31}&end&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)
### 1 函数调用关系:
[“26.为什么加载设备和加载驱动没有先后顺序”页上的图片](onenote:#26.为什么加载设备和加载驱动没有先后顺序&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={3E027B54-23DD-486C-87F0-9AEF2962EB31}&object-id={A2FD7644-AADA-40EF-AC92-BD7B682C94DF}&25&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 设备和驱动的绑定-跟踪代码分析

[“26.为什么加载设备和加载驱动没有先后顺序”页上的图片](onenote:#26.为什么加载设备和加载驱动没有先后顺序&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={3E027B54-23DD-486C-87F0-9AEF2962EB31}&object-id={A2FD7644-AADA-40EF-AC92-BD7B682C94DF}&35&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

- 1 就是不管在driver里面还是在设备里面，它都会去调用对应的匹配函数以及problem函数


### 3 




## 实例分析：platform总线上的驱动是如何注册的？
- 1 他跟我们之前讲的，驱动是如何注册到自己的总线上是一模一样的

### 1 platform总线的驱动是如何注册的。
[“27.实例分析：platform总线上的驱动是如何注册的？”页上的图片](onenote:#27.实例分析：platform总线上的驱动是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={2B5A132B-0D4F-448E-9246-3EA58A90D5B4}&object-id={A7CB8866-D45F-40DA-B718-5ACC7733F2DD}&15&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 2 probe 函数的执行
[“27.实例分析：platform总线上的驱动是如何注册的？”页上的图片](onenote:#27.实例分析：platform总线上的驱动是如何注册的？&section-id={B5873CA5-9995-405A-947B-6FCCADE2E1D2}&page-id={2B5A132B-0D4F-448E-9246-3EA58A90D5B4}&object-id={A7CB8866-D45F-40DA-B718-5ACC7733F2DD}&1B&base-path=https://d.docs.live.net/52d4b76bb0ffcf51/Documents/\(RK3568\)Linux驱动开发/第九期_设备模型.one)

### 3 



---
title: 
aliases: 
tags: 
description:
---

# 随记：




# 一、rs485_ctl.c杂项设备驱动
## 1、通用的杂项设备驱动框架
```c
#include <linux/init.h>              // 初始化头文件，包含module_init和module_exit宏
#include <linux/module.h>            // 包含模块支持的基本函数和宏定义
#include <linux/platform_device.h>   // 平台设备驱动模型相关的头文件
#include <linux/miscdevice.h>        // 注册杂项设备头文件
#include <linux/fs.h>                // 注册设备节点的文件结构体

// 定义用户空间命令：设置分辨率（示例命令）
#define STE_RESOLUTON _IOW('A', 0, int)

// 打开设备时调用的函数
static int rs485_open(struct inode *inode, struct file *file) {
    return 0; // 成功打开返回0
}

// 关闭设备时调用的函数
static int rs485_release(struct inode *inode, struct file *file) {
    return 0; // 成功关闭返回0
}

// 设备控制函数，处理来自用户空间的命令
static long rs485_ioctrl(struct file *file, unsigned int cmd, unsigned long args) {
    switch (cmd) {
        case STE_RESOLUTON:
            // 这里可以实现对分辨率的设置逻辑
            break;
        default:
            return -EINVAL; // 对于未知命令返回无效参数错误
    }
    return 0;
}

// 从设备读取数据时调用的函数
static ssize_t rs485_read(struct file *file, char __user *buf, size_t size, loff_t *off) {
    // 实现从设备读取数据到用户缓冲区buf的逻辑
    return 0; // 返回实际读取的数据大小
}

// 向设备写入数据时调用的函数
static ssize_t rs485_write(struct file *file, const char __user *buf, size_t size, loff_t *off) {
    // 实现将用户缓冲区buf的数据写入设备的逻辑
    return size; // 返回实际写入的数据大小
}

// 文件操作集合
struct file_operations rs485_misc_fops = {
    .owner = THIS_MODULE,            // 模块所有权引用，确保模块在使用中不可卸载
    .open = rs485_open,              // 打开设备
    .unlocked_ioctl = rs485_ioctrl,  // 控制设备（通过ioctl接口）
    .read = rs485_read,              // 从设备读取数据
    .write = rs485_write,            // 向设备写入数据
    .release = rs485_release         // 关闭设备
};

// 杂项设备描述符
struct miscdevice rs485_misc_dev = {
    .minor = MISC_DYNAMIC_MINOR,     // 动态分配次设备号
    .name = "rs485",                 // 设备名称
    .fops = &rs485_misc_fops         // 文件操作指针
};

// 探测函数，在加载驱动时调用
static int rs485_platform_driver_probe(struct platform_device *pdev) {
    // 注册杂项设备
    return misc_register(&rs485_misc_dev);
}

// 移除函数，在卸载驱动时调用
static int rs485_platform_driver_remove(struct platform_device *pdev) {
    // 注销杂项设备
    misc_deregister(&rs485_misc_dev);
    return 0;
}

// 设备匹配表
static const struct of_device_id of_rs485_ctrl_match[] = {
    { .compatible = "topeet,rs485_ctl" }, // 兼容性字符串，必须与设备树中的相匹配
    {},
};

// 定义平台驱动
static struct platform_driver rs485_platfrom_ctrl = {
    .driver = {
        .name = "rs485_ctl_gpio",
        .owner = THIS_MODULE,
        .of_match_table = of_rs485_ctrl_match,
    },
    .probe = rs485_platform_driver_probe,
    .remove = rs485_platform_driver_remove,
};

// 初始化函数，注册平台驱动
static int __init rs485_platform_driver_init(void) {
    return platform_driver_register(&rs485_platfrom_ctrl);
}

// 清理函数，注销平台驱动
static void __exit rs485_platform_driver_exit(void) {
    platform_driver_unregister(&rs485_platfrom_ctrl);
}

module_init(rs485_platform_driver_init);
module_exit(rs485_platform_driver_exit);

MODULE_DESCRIPTION("GPIO RS485控制驱动"); // 描述模块功能
MODULE_ALIAS("platform:rs485_ctrl");      // 模块别名
MODULE_LICENSE("GPL");                    // 许可证声明
```


## 2、GPIO函数

```c
struct gpio_desc *ctrl_gpio; // 用于存储GPIO控制器描述符

ctrl_gpio = gpiod_get_optional(dev, "ctrl", GPIOD_OUT_LOW); // 获取并配置GPIO

 gpiod_set_value(ctrl_gpio, state); // 设置GPIO值
 state = gpiod_get_value(ctrl_gpio); // 获取GPIO值

gpiod_put(ctrl_gpio); // 释放GPIO资源
```


## 3、设备树编写
### 


### 


### 



## 4、Makefile的编写
```bash
# 将rs485_ctl.o添加到obj-m变量中，表示该文件将被编译为一个模块
obj-y += rs485_ctl.o

# # 设置ARCH环境变量为arm64，指定目标架构为64位ARM架构
# export ARCH=arm64

# # KDIR变量设置为内核源代码目录的路径
# KDIR:=/home/topeet/rk3568/rk_android11.0_sdk_211130/kernel

# # PWD变量使用shell命令pwd获取当前工作目录路径，默认值为当前目录
# PWD?=$(shell pwd)

# # 定义all目标，这是默认执行的任务
# all:
# 	make -C $(KDIR) M=$(PWD) modules
```



## 5、ioctrl函数的讲解
### 应用层
#### 函数原型
```c
int ioctl(fd, cmd, &data);
```
> - ​**​`fd`​**​：通过 `open()` 获取的设备文件描述符（如 `/dev/ttyS0`）。
> - ​**​`cmd`​**​：预定义的命令码（Command），指定操作类型（如设置波特率、读取缓冲区大小）。
> - ​**​`data`​**​：可选参数，通常是指向数据结构的指针（如结构体、整型变量），用于输入或输出数据
> 

#### 用户层使用
```d
#define STE_WRITE _IOW('A', 0, int)

ioctl(fd, STE_WRITE, args);
```




#### 用户层与内核层使用相同的宏定义


### 驱动层
#### 函数原型
```c
static long mydev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
    switch(cmd) {
        case MYDEV_GET_DATA:  // 自定义命令
            copy_to_user((void __user *)arg, &kernel_data, sizeof(data));
            break;
        default:
            return -EINVAL;   // 无效命令
    }
    return 0;
}
```
- 2 **数据交换​**​：使用 `copy_from_user()`/`copy_to_user()` 安全读写用户空间内存
#### 驱动层定义
```d
#define STE_WRITE _IOW('A', 0, int)

static long rs485_ioctrl(struct file *file,unsigned int cmd,unsigned long args)
{



}



```




### 命令码（Command）规范​​
- 1 命令码是32位整数，按位域划分四个部分：

| ​**​位域​**​               | 作用         | 示例宏                |
| ------------------------ | ---------- | ------------------ |
| ​**​Type (8bit)​**​      | 设备类型标识（字母） | `'k'` 表示自定义设备      |
| ​**​Number (8bit)​**​    | 命令序号       | `1`, `2` 等         |
| ​**​Size (14bit)​**​     | 参数大小       | `sizeof(int)`      |
| ​**​Direction (2bit)​**​ | 数据方向       | `_IOC_READ`（用户读驱动） |

```d
#define STE_WRITE _IOW('A',0,int)  //写命令
#define STE_READ _IOR('A',1,int) //读命令
```



### 实例
```c
#define CMD_SWITCH_STATE _IOW('A',0,int) // 用户空间命令：切换GPIO状态
#define CMD_GET_STATE _IOR('A',1,int)    // 用户空间命令：获取GPIO状态

// 设备控制函数，处理来自用户空间的命令
static long rs485_ioctrl(struct file *file, unsigned int cmd, unsigned long args) {
    int state;
    int ret;
    switch (cmd) {
        case CMD_SWITCH_STATE:
            if (copy_from_user(&state, (int __user *)args, sizeof(int))) { // 从用户空间复制数据到内核空间
                ret = -EFAULT;
                break;
            }
            gpiod_set_value(ctrl_gpio, state); // 设置GPIO值
            break;
        case CMD_GET_STATE:
            state = gpiod_get_value(ctrl_gpio); // 获取GPIO值
            if (copy_to_user((int __user *)args, &state, sizeof(int))) { // 将内核空间的数据复制到用户空间
                ret = -EFAULT;
            }
            break;
        default:
            return -1; // 对于未知命令返回错误
    }
    return 0;
}



```



# 二、

## 1、
### 


### 


### 


## 2、

### 


### 


### 



## 3、
### 


### 


### 



## 4、
### 


### 


### 




## 5、
### 


### 


### 




# 三、

## 1、
### 


### 


### 


## 2、

### 


### 


### 



## 3、
### 


### 


### 



## 4、
### 


### 


### 




## 5、
### 


### 


### 



# 四、

## 1、
### 


### 


### 


## 2、

### 


### 


### 



## 3、
### 


### 


### 



## 4、
### 


### 


### 




## 5、
### 


### 


### 









# 五、

## 1、
### 


### 


### 


## 2、

### 


### 


### 



## 3、
### 


### 


### 



## 4、
### 


### 


### 




## 5、
### 


### 


### 




# 六、

## 1、
### 


### 


### 


## 2、

### 


### 


### 



## 3、
### 


### 


### 



## 4、
### 


### 


### 




## 5、
### 


### 


### 

---
title: "{{title}}"
aliases: 
tags: 
description: 
source:
---

# 备注(声明)：




# 一、

## 什么是面向对象编程？
### 1 、以 “对象” 为核心
- 1 对象，可以理解为现实世界中具体的事物（如一辆车、一个人）或抽象的概念（如一个订单、一次交易），它包含两部分：

> - **属性**：描述对象的特征（如车的颜色、价格；人的姓名、年龄）
> - **方法**：对象能执行的操作（如车能行驶、刹车；人能吃饭、睡觉）


### 2 、将问题拆解为多个对象，通过对象之间的交互来解决问题


### 3 、



### 4 、



### 5、


### 6、


### 7、


### 8、



## OOP 的三大核心特性
### 1 、 封装（Encapsulation）：数据安全的第一道防线
- 1 将对象的属性和方法捆绑在一起，并对外隐藏内部实现细节，只通过公开的接口与外界交互。

```java
public class Person{

	// 私有属性（仅内部可见）​
	private String name;
	private int age;
	
	// 公开方法（对外接口）​
	public void setAge(int age){
		if(age>0&&age<150){
			this.age=age;
	
		}else{
			System.out.println("年龄输入无效");
		}
	
	}
	
	public int getAge(){
	
		return age;
	}

}

```

> - 这里name和age被private修饰，外部无法直接修改
> - **只能通过setAge()方法修改年龄**，且该方法包含校验逻辑，避免不合理数据（如年龄 =-5 或 200）
> - 优势：提高代码安全性，降低外部依赖，便于后续维护



### 2 、继承（Inheritance）：代码复用的利器
- 1 子类）继承（父类）的属性和方法，并可以在此基础上扩展新功能。
```java
// 父类​
public class Animal {
​
	protected String name;
	​
	public void eat() {​
	
		System.out.println(name + "在吃东西");​
	
	}​

}


//子类
public class Dog extends Animal{

	// 继承父类的name和eat()方法​
	
	// 扩展子类特有方法​
	pubilc void bark(){
		System.out.println(name + "汪汪叫");
		
	}


}

```
- 1 子类可通过@Override重写父类方法，实现个性化逻辑（如猫吃小鱼干，而不是通用的 “吃东西”）
```java
public class Cat extends Animal {​

	@Override // 重写父类方法​
	public void eat() {​
		System.out.println(name + "在吃小鱼干");​

	}​

	public void meow() {​

		System.out.println(name + "喵喵叫");​

	}​
	
}
```

> - 子类通过**extends关键字继承父类**，减少重复代码
> - 子类可通过<span style="background:#affad1">@Override重写父类方法</span>，实现个性化逻辑（如猫吃小鱼干，而不是通用的 “吃东西”）
> - 优势：实现代码复用，建立类之间的层次关系，增强扩展性

### 3 、多态（Polymorphism）：同一种行为，不同子类同时实现
- 1 同一操作作用于不同对象时，产生不同的执行结果
- 1 允许我们用父类引用指向子类对象，从而实现灵活的调用。

```java
public class Test{
	public static void main(String[] args){
		
		// 父类引用指向子类的对象​
		Animal dog =new Dog();
		Animal cat =new Cat();

		dog.name="旺财";
		cat.name="咪宝";

		feed(dog); // 输出：旺财在吃东西​
		feed(cat); // 输出：咪宝在吃小鱼干（调用的是子类重写的方法）​

	
	
	}


	// 接收父类类型，可传入任意子类对象​
	public static void feed(Animal animal){
	
		animal.eat();// 根据实际对象类型执行不同逻辑​
	}


}

```


> - 方法feed(Animal animal)**只需定义一次，即可接收Dog、Cat等所有Animal子类对象**
> - 运行时会自动调用子类重写的方法，实现 “同一种行为，不同实现”
> - 优势：降低代码耦合度，提高扩展性（新增动物类时，无需修改feed方法）


### 4 、OOP 与面向过程的对比

| 维度   | 面向过程编程         | 面向对象编程               |
| ---- | -------------- | -------------------- |
| 核心单元 | 函数（Function）   | 类和对象（Class & Object） |
| 思维方式 | 按步骤拆解问题（“怎么做”） | 按对象拆解问题（“谁来做”）       |
| 代码复用 | 依赖函数复用，复用性低    | 通过继承、多态实现高复用性        |
| 扩展性  | 修改一处可能影响多个函数   | 封装隔离，修改影响范围小         |
| 适用场景 | 简单程序（如计算器、脚本）  | 复杂系统（如电商平台、APP）      |
|      |                |                      |

- 1 总结：面向过程适合简单场景，逻辑清晰直接；OOP 适合复杂场景，更易维护和扩展。

### 5、


### 6、


### 7、


### 8、



## 
### 1 、OOP 的实际应用场景
> 1. 大型软件系统：如电商平台（用户、商品、订单等对象清晰分离）
> 2. 游戏开发：角色、道具、场景等均以对象形式存在，通过交互实现游戏逻辑
> 3. GUI 开发：按钮、输入框等组件本质上都是对象，封装了显示和交互逻辑
> 4. 框架设计：Spring、React 等主流框架均基于 OOP 思想，通过类和对象实现核心功能

### 2 、OOP 设计原则（SOLID）

> - 单一职责：**一个类只负责一项功能**
> - 开放 - 封闭：**对外扩展开放，对内修改封闭**
> - 里氏替换：子类可替换父类，且不影响程序正确性
> - 接口隔离：避免过大的接口，拆分出更具体的接口
> - 依赖倒置：**依赖抽象，而非具体实现**


### 3 、掌握 OOP 的关键在于：

> 1. 学会**从现实世界中抽象对象（属性 + 方法）**
> 2. 合理设计类之间的关系（继承、组合等）
> 3. 灵活运用三大特性解决实际问题


### 4 、



### 5、


### 6、


### 7、


### 8、




# 二、

## 
### 1 、


### 2 、


### 3 、



### 4 、



### 5、


### 6、


### 7、


### 8、




## 
### 1 、


### 2 、


### 3 、



### 4 、


### 5、


### 6、


### 7、


### 8、



## 
### 1 、


### 2 、


### 3 、



### 4 、



### 5、


### 6、


### 7、


### 8、


# 三、

## 
### 1 、


### 2 、


### 3 、



### 4 、



### 5、


### 6、


### 7、


### 8、



## 
### 1 、


### 2 、


### 3 、



### 4 、


### 5、


### 6、


### 7、


### 8、



## 
### 1 、


### 2 、


### 3 、



### 4 、



### 5、


### 6、


### 7、


### 8、


# 四、

## 
### 1 、


### 2 、


### 3 、



### 4 、



### 5、


### 6、


### 7、


### 8、



## 
### 1 、


### 2 、


### 3 、



### 4 、


### 5、


### 6、


### 7、


### 8、



## 
### 1 、


### 2 、


### 3 、



### 4 、



### 5、


### 6、


### 7、


### 8、


# 五、

## 
### 1 、


### 2 、


### 3 、



### 4 、



### 5、


### 6、


### 7、


### 8、



## 
### 1 、


### 2 、


### 3 、



### 4 、


### 5、


### 6、


### 7、


### 8、



## 
### 1 、


### 2 、


### 3 、



### 4 、



### 5、


### 6、


### 7、


### 8、


